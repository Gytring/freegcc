<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu上安装编译Opencv]]></title>
    <url>%2F2018%2F09%2F05%2FUbuntu%E4%B8%8A%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91Opencv%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;安装环境 Ubuntu 14.04 纯 CPU，主要是台式机没有显卡，不用关心GPU显卡驱动以及Cuda的安装；这样的好处是编译 Opencv 比较快，基本无报错。以opencv3.4.3为例。 &emsp;&emsp;但在此还是简单缀叙一下显卡驱动和 Cuda 的安装，注意是英伟达的显卡： 123456789101112sudo apt-get updatesudo apt-get install nvidia-375* -ynvidia-smi###这种方式比较简单，也可以从官方下载对应的***.run驱动进行安装###需要注意的地方就是尽量不要使用UEFI的方式安装系统，否则显卡驱动装不上，具体原因未知###而且在用**.run驱动装的时候，需要禁用nouveau###编辑/etc/modprobe.d/blacklist.conf，在末尾加上一行：blacklist nouveau###重启，关闭图形界面：sudo service lightdm stop###Ctrl + Alt + F1~F6 进入物理终端###sudo bash NVIDIA-****.run --no-opengl-files 进行安装###查看是否安装成功：nvidia-smi###开启图形界面sudo service lightdm start，Ctrl + Alt + F7 进入图形界面 &emsp;&emsp;安装 Cuda ，先下载cuda的run驱动 1sudo sh cuda_8.xx.xxx_linux.run &emsp;&emsp;安装依赖 1234567sudo apt-get -y install vim openssh-server git wget sudo apt-get -y install libxml2-dev libxslt1-dev python-devsudo apt-get -y install build-essential gfortran libfreetype6-dev python-dev cmake python-tksudo apt-get -y install libgflags-dev libboost-dev libboost-filesystem-dev libboost-regex-dev libboost-python-dev libX11-devsudo apt-get -y install libgoogle-glog-dev libprotobuf-dev libleveldb-dev sudo apt-get -y install libopenblas-dev libboost-system-dev libatlas3-basesudo apt-get -y install liblmdb-dev libavcodec-dev libavformat-dev libavutil-dev libswscale-dev &emsp;&emsp;下载并安装 cudnn 123sudo tar xvf cudnn-8.0-linux-x64-v5.1.tgzsudo cp cuda/include/*.h /usr/local/cuda-8.0/include/sudo cp cuda/lib64/lib* /usr/local/cuda-8.0/lib64/ &emsp;&emsp;配置环境变量 12345###编辑~/.bashrc并加上如下两行export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:/usr/local/lib:$LD_LIBRARY_PATH###重读配置文件使其生效source ~/.bashrc &emsp;&emsp;安装Opencv 库依赖 123sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev &emsp;&emsp;下载 opencv 源文件 12###opencv3.4.3和opencv_contrib3.4.3下载地址,若要编译其他版本的opencv，注意保持opencv和opencv_contrib版本一致https://github.com/opencv &emsp;&emsp;将opencv和opencv_contrib解压到家目录下 123456cd opencv-3.4.3mkdir buildcd buildcmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.4.3/modules/ ..###如果不安装opencv_contrib模块，则执行：cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. ##或者cmake .. &emsp;&emsp;编译安装，make 或者 make -j8 (-j8是指你电脑可用的内核数，有的是j4） 123456make -j8#等待时间可能会很长,特别是代GPU和Cudasudo make install#注意一定要加sudo，否则会报出permission问题pkg-config --modversion opencv#安装完成后查看opencv版本 &emsp;&emsp;环境配置 1234567891011sudo cat &gt;&gt; /etc/ld.so.conf &lt;&lt;EOF/usr/local/libEOFsudo ldconfigsudo cat &gt;&gt; /etc/bash.bashrc &lt;&lt;EOFPKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig export PKG_CONFIG_PATH EOFsource /etc/bash.bashrc &emsp;&emsp;最后，在给服务器装系统的时候，会遇到卡在黑屏的界面，本人被坑过两次；显示屏接VGA，无法进BIOS，黑屏；接HDMI可以进BIOS，但后面进不了安装界面，黑屏；此时需要在BIOS中修改显卡的相关设置，不同的BIOS设置项不一样，但基本都是带”Graphic”、”Display”之类的设置项。修改后支持VGA信号，就可成功装上系统。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记(5)]]></title>
    <url>%2F2018%2F09%2F03%2FLinux%E7%AC%94%E8%AE%B0-5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;grep: global search regular expression(RE) and print out the line；全面搜索正则表达式并把行打印出来。它是一种强大的文本搜索工具，但只能使用基本的正则表达式来搜索文本。 &emsp;&emsp;egrep等同于grep -E：使用扩展的正则表达式对文本进行搜索，并把符合用户需求的字符串打印出来。 &emsp;&emsp;fgrep等同于grep -F：搜索固定的字符串，但不解析正则表达式，所以此命令的执行速度也最快。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889###用法grep [option] 'PATTERN模式' filename...###PATTERN模式:搜索的字符串及正则表达式参数###常用的option： -v：查找不包含匹配项的行 -i：忽略大小写 -c：打印匹配的行数 -n：显示匹配的行号 -E：使用扩展正则表达式即egrep -F: 即fgrep -o: 仅显示匹配到的内容而非整行 -R/-r：此参数的效果和指定“-d recurse”参数相同，递归的读取目录下的所有文件，包括子目录 -A N：显示模式匹配到的行以及后面的N行 -B N：显示模式匹配到的行以及前面的N行 -C N：显示模式匹配到的行以及上下的N行 --color :将匹配到的内容以颜色高亮显示，基本上grep都在配置文件中alias grep='grep --color'###简单的正则表达式.：匹配任意的单个字符的[]：指定范围内的任意的单个字符 [0-9] [[:digit:]]:表示匹配0到9的任意单个数字、两种表示方法都可以 [a-z] [[:lower:]]:表示匹配小写的a到z的任意单个字母、即a-z [A-Z] [[:upper:]]:表示匹配大写的A到Z的任意单个字母、即A-Z [[:alpha:]]：表示英文大小写字母、即：a-z，A-Z [[:space:]]：表示包含的空白字符、即空格键，tab键 [[:alnum:]]：表示包含数字大小写字母、即0-9，A-Z，a-z [[:punct:]]：表示包含标点符号、即：" ' ? ! ; : # $ . ..[^]: 表示指定范围外的任意单个字符、就是使用了脱字符取反字符的次数匹配：用来匹配其前面的字符的次数的 *：(星号)匹配其紧挨着星号的字符出现任意次 例：x*y就是x可以出现意次、包括0次 .*：(点星)匹配任意长度的任意字符 \?：表示其前面的字符出现0次或者1次、\是转义字符 例：x\?y：可以匹配到的只有xy和y \&#123;m\&#125;：匹配m次 例：x\&#123;4\&#125;y表示y前面的x出现4次就可以被匹配到 \&#123;m,n\&#125;：至少m次，至多n次 例： x\&#123;1，4\&#125;y表示y前面的x出现1到4次就可以被匹配到 \&#123;m,\&#125;：至少m次 \&#123;0,n\&#125;：至多匹配n次、0不可以省略位置锚定符：用于指定字符出现的位置 ^：用于锚定行首 例：(^string) grep '^root' /etc/passwd $：用于锚定行尾 例：(string$) grep 'bash$' /etc/passwd ^$：空白行、查找一个文件中所出现的空白行 ^hello$表示只有hello的行单词的锚定： \&lt;char：锚定词首，\&lt;[r]表示一行以r开头的单词都可以匹配、也可以使用\b表示 char\&gt;：锚定词尾，一行以r开头的单词都可以匹配、\b \&lt;hello\&gt;：表示精确锚定hello这个单词 \&lt;h…o\&gt;：表示以h开头、以o结尾、中间跟了任意三个字符的单词分组元字符： \(\)：分组 \是转义字符 例：\(ab\)*xy，ab括起来表示一个组了，xy前面的ab组现出任意次，可以被匹配到引用： 对分组的字符块进行引用 \1：后向引用，引用前面的第一个左括号以及与之对应的右括号中模式所匹配到的内容 \2：后向引用，引用前面的第二个左括号以及与之对应的右括号中模式所匹配到的内容 例：\(a.b\)xy\1 可以匹配到的有(abxyab不可以匹配到) akbxyakb,a3bxya3b,aYbxyaYb###拓展正则表达式很多地方和基本正则表达式相同，有些地方少了转义字符 \元字符：字符匹配 .：匹配任意单个字符 []：指定范围内的任意单个字符次数匹配： *：匹配其紧挨着星号的字符出现任意次 ?：表示其前面的字符出现0次或者1次 +：匹配其前面的字符至少1次 &#123;m&#125;：匹配其前面的字符m次 &#123;m,n&#125;：至少m次，至多n次 &#123;m,&#125;：至少m次 &#123;0,n&#125;：至多n次位置锚定： ^：行首锚定 $：行尾锚定 \&lt;：词首 \&gt;：词尾分组： ()：分组 |：或者 例：ab|xy意思为ab或者xy a(b|x)y意思为aby或者axy###示例grep 'test' free* 显示所有以free开头的文件中包含test的行grep '[a-z]\&#123;5\&#125;' free 显示free文件中所有包含至少有5个连续小写字符的字符串的行grep -c "test" free 显示free文件中含有test的行数grep -n "test" free 显示free文件所有匹配test的行和行号grep '^[^test]' free 不匹配行首是test的行grep -o "test" free 只显示匹配到的testgrep –v "test" free 显示不包含test的行grep -R "test" . 显示当前目录(含子目录)下所有文件中匹配test的行grep -c "^$" free 统计空白行的行数 &emsp;&emsp;对于 Linux 环境问题缺库少库解决办法就是缺啥补啥。 &emsp;&emsp;Linux一般的配置文件在 /etc/sysconfig/network 目录下，修改配置文件不会立即生效，但重启网络服务或主机会生效。 &emsp;&emsp;状态代码： &emsp;&emsp;1xx：纯信息 &emsp;&emsp;2xx：成功类信息 &emsp;&emsp;3xx：重定向类信息 &emsp;&emsp;4xx：客户端错误类信息 &emsp;&emsp;5xx：服务器端错误类信息 &emsp;&emsp;在vim中直接查看文件编码：set fileencoding &emsp;&emsp;使用 iconv经行文件编码转换 1iconv filename1 -f encoding -t encoding -o filename2 &emsp;&emsp;使用SCP传输文件： &emsp;&emsp;scp username@IP:filepath filepath &emsp;&emsp;scp -p port filepath user@IP:pathname filepath]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记(4)]]></title>
    <url>%2F2018%2F09%2F03%2FLinux%E7%AC%94%E8%AE%B0-4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在 Linux 中有3个常用的文件描述符，0(STDIN_FILNENO)代表标准输入，1(STDOUT_FILENO)代表标准输出，2(STDERR_FILENO)代表标准出错 ；一般每个进程最多允许同时打开1024个文件描述符，可用 ulimit -a 查看。 12345678910111213141516core file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 63928max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 63928virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited &emsp;&emsp;在 C 语言中，stdin、stdout、stderr 也分别代表标准输入、标准输出、标准出错，不过 stdin 是 FILE类型，STDIN_FILENO 是 int 类型；使用stdin的函数主要有：fread、fwrite、fclose等，基本上都以f开头的 C语言库函数；使用STDIN_FILENO的函数有：read、write、close等，是 UNIX 类系统在&lt;unistd.h&gt;文件中定义的预编译宏。程序启动时：**FILE \ stdin / stdout / stderr 对应的 文件描述符(fd)分别是 STDIN_FILENO(0) /STDOUT_FILENO(1) / STDERR_FILENO(2)**。 &emsp;&emsp;在 Linux 命令行上，经常会用到输入输出重定向： 12345标准输入stdin：对应的文件描述符是0，符号是&lt;和&lt;&lt;，/dev/stdin -&gt; /proc/self/fd/0标准输出stdout：对应的文件描述符是1，符号是&gt;和&gt;&gt;，/dev/stdout -&gt; /proc/self/fd/1标准错误stderr：对应的文件描述符是2，符号是2&gt;和2&gt;&gt;，/dev/stderr -&gt; /proc/self/fd/2 &emsp;&emsp;输出重定向示例： 1234567891011121314151617181920212223242526272829303132333435#默认情况下，stdin获取屏幕的输入(键盘)，stdout和stderr默认输出到屏幕#标准输出将ls的结果重定向到stdout文件中，错误输出默认到屏幕；1&gt;与&gt;等价[deepcam@test ~]$ ls &gt; stdout[deepcam@test ~]$ cat stdoutDesktopDocumentsDownloadsexamples.desktopfree.shMusicNVIDIA-Linux-x86_64-384.111.runPicturesPublicsrcstdoutTemplatesupdateVideos#标准输出将ls(gcc文件不存在，ls会出错)的结果重定向到stdout，错误输出到stderr,也可以使用追加&gt;&gt;模式。[deepcam@test ~]$ ls gcc free.sh &gt;stdout 2&gt;stderr[deepcam@test ~]$ cat stdout stderrfree.shls: cannot access gcc: No such file or directory#将错误输出关闭，输出到null；同样也可以将stdout重定向到null或关闭# &amp;1代表标准输出，&amp;2代表标准错误，&amp;-代表关闭与它绑定的描述符[deepcam@test ~]$ ls gcc free.sh 2&gt;&amp;-free.sh#不关心错误输出，将其送到黑洞 /dev/null中[deepcam@test ~]$ ls gcc free.sh 2&gt;/dev/null free.sh#&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1，即和1重定向的文件系统上的位置是一样的#&amp;&gt; 等同与 2&gt;&amp;1#将错误输出和标注输出同时重定给/dev/null(不关心输出结果，常用在脚本中)，也可以重定向到一个文件[deepcam@test ~]$ ls gcc free.sh &gt; /dev/null 2&gt;&amp;1[deepcam@test ~]$ ls gcc free.sh &amp;&gt; /dev/null &emsp;&emsp;输入重定向示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#stdin获取屏幕的输入(键盘)，然后输出到file文件，按Ctrl+d结束(表示文件结束的标志)#&gt; 写到文件回覆盖以前的内容，而 &gt;&gt; 会追加内容到文件[deepcam@test ~]$ cat &gt; filethisis afile[deepcam@test ~]$ cat filethisis afile#输入特定字符EOF，自动结束stdin，常用于向一个文件写内容[deepcam@test ~]$ cat &gt; test &lt;&lt;EOF&gt; this&gt; is&gt; a&gt; test&gt; EOF[deepcam@test ~]$ cat testthisisatest#使用&gt;&gt; 追加[deepcam@test ~]$ cat &gt;&gt; test &lt;&lt;EOF&gt; append&gt; hello&gt; world&gt; EOF[deepcam@test ~]$ cat testthisisatestappendhelloworld#tac查看的内容和cat内容是倒过来的[deepcam@test ~]$ tac testworldhelloappendtestaisthis#rev是cat查看的内容反过来[deepcam@test ~]$ rev testsihtsiatsetdneppaollehdlrow &emsp;&emsp;find的常见用法: 1234567891011121314151617181920212223242526find path -option [ -print ] [ -exec -ok command ] &#123;&#125; \;#path表示所查找的路径#-option命令行选项#-print将匹配的结果输出到标准输出，默认操作#-exec command &#123;&#125; \;：find命令对匹配的文件执行该参数所给出的shell命令；注意&#123;&#125;和\；之间的空格。&#123;&#125;即为find查找的结果，\;表示转义;#-ok：和-exec相同，只不过在操作前要询用户#-option选项有很多，可以多个组合取交集，常见的有 -name 按文件名查找，支持正则表达式 -iname 同name，不区分大小写，不完全支持正则表达式 -type 根据文件类型查找：f、d、p、l、s、c、b -empty 空文件或目录 -perm 根据权限查找文件 -user 根据文件所有者查找文件 -group 按组查找 -nouser 查找文件的用户ID不存在的文件 -mtime -n 按文件更改时间来查找文件，-n指n天以内，+n指n天以前 -atime -n 按文件访问时间来查 -ctime -n 按文件创建时间来查找文件 -size -n 根据大小查找文件，-n大小小于n，n大小等于n，+n大小大于n -prune 忽略某个目录，多用于组合#find . -name "[A-Z]*" -print 查以大写字母开头的文件#find . -perm -777 -exec ls -l &#123;&#125; \; 查所有用户都可读写执行的文件#find . -size +1000000c -print 查长度大于1Mb的文件#find . -name .svn | xargs rm -rf 找到当前目录下所有名为.svn的文件并删除#find ./ -empty -type f -print -delete 查找空文件并删除 &emsp;&emsp;通常Linux命令可以用|首尾相连，上一个命令的 stdout 连接到下一个命令的 stdin，标准输出作为后面命令的标准输入。但是如果命令不支持接收标准输入，那么就不能直接使用管道，比如ls、rm等，是从命令行参数接受输入的。这时候如果想把上一个命令的输出传给它们，就不好办了。所以就有了xargs。 &emsp;&emsp;简单而言，xargs可以把从 stdin 接受到的输入，按空白符或加车符分隔开，然后依次作为参数去调用xargs后面的命令；xargs的默认命令是echo，空格是默认定界符。 12345#-d 指定分隔符#-n 传递参数的个数#-p 询问是否执行，输入 y 继续执行，否则不执行#-a file 从文件中读入作为sdtin#-e flag 当xargs分析到含有flag这个标志的时候就停止 &emsp;&emsp;在使用 find 配合 -exec 选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给 exec 执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现 溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。find命令把匹配到的文件 传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一 批，并如此继续下去。 12345678#查找所有的jpg 文件，并且压缩它# find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz#用rm删除过多的文件，产生错误信息：/bin/rm Argument list too long. 用xargs去避免这个问题#find ~ -name ‘*.log’ -print0 | xargs -i -0 rm -f &#123;&#125;#ls *.txt | xargs -t -i mv &#123;&#125; &#123;&#125;.bak mv 1.txt 1.txt.bak mv 2.txt 2.txt.bak mv 3.txt 3.txt.bak]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerLine]]></title>
    <url>%2F2018%2F08%2F27%2FPowerLine%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;&emsp;&emsp;Powerline是一个stateless status line，即一个全局状态/提示栏。要用于显示状态行和提示信息，适用于很多软件，比如 bash、zsh、vim、tmux 等等。 &emsp;&emsp;Powerline 的安装方法很简单，首先介绍安装在命令行上，适用于bash、zsh等。 &emsp;&emsp;安装Python环境 12sudo apt-get install python-pip #Debian、Ubuntu等sudo yum install python-pip #CentOS、RHEL等 &emsp;&emsp;使用 Python 安装PowerLine 1sudo pip install powerline-shell #还有一种就是powerline-status &emsp;&emsp;生成配置文件 1mkdir -p ~/.config/powerline-shell &amp;&amp; powerline-shell --generate-config &gt; ~/.config/powerline-shell/config.json &emsp;&emsp;简单的更改配置文件 123456789101112131415cat &gt; ~/.config/powerline-shell/config.json &lt;&lt;EOF&#123; "segments": [ "virtual_env", "username", "ssh", "cwd", "git", "git_stash", "jobs", "newline", "root" ]&#125;EOF &emsp;&emsp;至此已经可以使用powerline了，效果如下图： &emsp;&emsp;在 vim 里面使用 PowerLine 则需要安装 vim 的一个插件VundleVim； &emsp;&emsp;创建 bundle 目录 1mkdir -p ~/.vim/bundle &emsp;&emsp;安装Vundle 1git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim &emsp;&emsp;更改配置文件 1234567891011121314151617181920212223242526272829set nocompatible " 这是必需的 filetype off " 这是必需的 " 你在此设置运行时路径 set rtp+=~/.vim/bundle/Vundle.vim " vundle初始化 call vundle#begin() " 这应该始终是第一个 Plugin 'gmarik/Vundle.vim' " 该例子来自https://github.com/gmarik/Vundle.vim README Plugin 'tpope/vim-fugitive' " 来自http://vim-scripts.org/vim/scripts.html的插件 Plugin 'L9' "未托管在GitHub上的Git插件 Plugin 'git://git.wincent.com/command-t.git'"PowerlineBundle "Lokaltog/vim-powerline"" sparkup vim脚本在名为vim的该软件库子目录下。 " 传递路径，合理设置运行时路径。 Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125; "每个插件都应该在这一行之前 call vundle#end() " required &emsp;&emsp;默认情况下，Vundle从github.com或vim-scripts.org下载并安装Vim插件，你也可以进行更改。 &emsp;&emsp;从GitHub安装: 1Plugin 'user/plugin' &emsp;&emsp;从 http://vim-scripts.org/vim/scripts.html 进行安装： 1Plugin 'plugin_name' &emsp;&emsp;从另一个git软件库进行安装： 1Plugin 'git://git.another_repo.com/plugin' &emsp;&emsp;从本地文件进行安装: 1Plugin 'file:///home/user/path/to/plugin' &emsp;&emsp;也可以自己定制其他参数，比如插件的运行时路径，如果你在自行编写插件，或者就想从不是~/.vim的另一个目录来装入它 1Plugin 'rstacruz/sparkup', &#123;'rtp': 'another_vim_path/'&#125; &emsp;&emsp;如果你有同样名称的插件，可以更名插件，那样它就不会冲突 1Plugin 'user/plugin', &#123;'name': 'newPlugin'&#125; &emsp;&emsp;PluginInstall命令会安装在你的.vimrc文件中列出来的所有插件 1:PluginInstall #vim的末行模式 &emsp;&emsp;清理插件 1:PluginClean &emsp;&emsp;上面已经将 PowerLine写进了配置文件，在 vim 效果如下 &emsp;&emsp;本人一般用的是Xshell 远程连接服务器，Powerline 字体是无法显示的，附上PowerLine字体的GitHub链接 Powerline Font 以及powerline-shell 的链接 powerline-shel。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PowerLine</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UNIX环境高级编程第十一章线程]]></title>
    <url>%2F2018%2F08%2F14%2FUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在跑APUE十一章线程 11-5 的例子时，下边一行代码会有报错提示： 1pthread_cleanup_push(cleanup, "thread 1 first handler"); &emsp;&emsp;提示：no matching constructor for initialization of &#39;__pthread_cleanup_class&#39;。 &emsp;&emsp;相对于C语言而言，C++对类型要求更严格，不同的不兼容类型之间不能直接转换，比如在C++中，int (int指针)类型和unsigned long类型就不允许直接转换，必须使用reinterpret_cast来进行类型转换，而C语言则可以使用(unsigned long)这种形式进行转换。此外，C++和const对象和非const对象也不能随意转换，从非const对象可以加上const属性转换到const对象，反之则不可以，上述代码中的 “thread 1 first handler” 的类型是const char ，而pthread_cleanup_push函数函数原型为： 1void pthread_cleanup_push(void (*routine)(void *), void *arg); &emsp;&emsp;其第二个参数类型为void ，无法从实参const char 类型转换到形参char *类型，因此该就没有匹配的构造函数来调用。 &emsp;&emsp;解决方法是将第二个参数使用字符数组来存储，然后将数组传递给形参，数组名会自动转换到指针，如下： 12char p1[] = "thread 2 first handler";pthread_cleanup_push(cleanup, p1); &emsp;&emsp;至于为什么这个C语言版本的UNIX库函数调用会涉及到C++的类及构造函数，是因为该头文件检测到使用C++编译器时，就额外封装pthread_cleanup_class类，具体细节可自行查看/usr/include/pthread.h头文件。 &emsp;&emsp;pthread_cleanup_push/pop 函数和C++的异常处理机制之间有着未知的相互影响或者潜在的冲突，因此不要在C++中调用pthread_cleanup_push/pop函数。 &emsp;&emsp;11-5源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include "apue.h"#include &lt;pthread.h&gt;void cleanup(void *arg)&#123; printf("cleanup %s\n", (char *)arg);&#125;void *thr_fn1(void *arg)&#123; char p1[] = "thread 1 first handler"; char p2[] = "thread 1 second handler"; printf("thread 1 statrt\n"); pthread_cleanup_push(cleanup, p1); pthread_cleanup_push(cleanup, p2); printf("thread 1 push compelete\n"); if(arg) return ((void *)1); pthread_cleanup_pop(0); pthread_cleanup_pop(0); return ((void *)1);&#125;void *thr_fn2(void *arg)&#123; char p1[] = "thread 1 first handler"; char p2[] = "thread 2 second handler"; printf("thread 2 start\n"); pthread_cleanup_push(cleanup, p1); pthread_cleanup_push(cleanup, p2); printf("thread 2 push complete\n"); if(arg) pthread_exit((void *)2); pthread_cleanup_pop(0); pthread_cleanup_pop(0); pthread_exit((void *)2);&#125;int main(void)&#123; int err; pthread_t tid1, tid2; void *tret; err = pthread_create(&amp;tid1, NULL, thr_fn1, ((void *)1)); if(err != 0) err_exit(err, "cannot create thread 1"); err = pthread_create(&amp;tid2, NULL, thr_fn2, ((void * )1)); if(err != 0) err_exit(err, "cannot create thread2"); err = pthread_join(tid1, &amp;tret); if(err != 0) err_exit(err, "cannot join with thread 1"); printf("thread 1 exit code %ld\n", (long)tret); err = pthread_join(tid2, &amp;tret); if(err != 0) err_exit(err, "cannot join with thrad 2"); printf("thread 2 exit code %ld\n", (long)tret); exit(0);&#125; &emsp;&emsp;但这个例子代 CentOS7 和 Ubuntu 14.04.5 上运行的结果有很大的出入，应该适合 Linux 内核的版本有关 &emsp;&emsp;Ubuntu 上 12uname -a#Linux zhenyan 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:07:32 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux &emsp;&emsp;CentOS 7 上: 12uname -a#Linux hurd 3.10.0-693.21.1.el7.x86_64 #1 SMP Wed Mar 7 19:03:37 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux &emsp;&emsp;可以很明显的看到在 CentOS 7上线程 1 退出了，线程 2 才开始，运行多次结果不会发送变化；而在 Ubuntu 上则有较大的随机性，线程 1 和 线程 2 的启动顺序不能确定，而且基本都是在线程 1 结束之前启动线程 2 ，只有一次例外，这种结果与书中给出的结果较为贴近。造成这种结果的原因可能和内核的调度和内核不同版本的实现有关。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
        <tag>pthread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux包管理器之PACMAN]]></title>
    <url>%2F2018%2F08%2F13%2FLinux%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B9%8BPACMAN%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Pacman 是一个软件包管理器,，作为 ArchLinux 发行版的一部分，是 Arch Linux 的鲜明特色。它将一个简单的二进制包格式和易用的构建系统结合了起来。不管软件包是来自官方的 Arch 库还是用户自己创建，Pacman 都能方便的管理。 &emsp;&emsp;Pacman 通过和主服务器同步软件包列表来进行系统更新，这使得注重安全的系统管理员的维护工作成为轻而易举的事情。这种服务器/客户端模式可以使用一条命令就下载/安装软件包，同时安装必需的依赖包。 &emsp;&emsp;常用命令： 1234567891011pacman -S ：安装pacman -Ss ：查询pacman -R ：删除pacman -Rs ：删除包和其依赖pacman -Qs ：查询已安装包pacman -Qi ：显示查找的包的信息pacman -Ql ：显示包的文件安装位置pacman -Sw ：下载包但不安装pacman -U /path/ ： 安装本地的包pacman -Scc ： 清除缓存pacman -Syu ：对整个系统更新 &emsp;&emsp;yaourt-Yet AnOther User Repository Tool 是arch linux方便使用的关键部件之一 ，但没有被整合到系统安装中的工具。建议在装完系统重启之后，更新完pacman和基本系统之后，就安装这个工具。 &emsp;&emsp;最简单安装 Yaourt 的方式是添加 Yaourt 源至到 /etc/pacman.conf 1234[archlinuxcn]#The Chinese Arch Linux communities packages.SigLevel = Optional TrustedOnlyServer = http://repo.archlinuxcn.org/$arch 1pacman -Syu yaourt #同步安装 &emsp;&emsp; yaourt 常用命令 123456789yaourt -S package_name – 从AUR安装软件包yaourt -Ss password – 使用关键字搜索软件包yaourt -Syu –aur – 从AUR升级本地软件数据库并安装更新yaourt -Si package_name – 列出软件包信息yaourt -Sc – 从缓存中清楚旧的软件包yaourt -Su – 安装AUR中的更新软件包yaourt -Sy – 获取最新的AUR软件包数据库yaourt -Cd – 清楚AUR软件包数据库yaourt -R package_name – 删除软件包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PACMAN</tag>
        <tag>Arch Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux包管理器之DPKG]]></title>
    <url>%2F2018%2F08%2F13%2FLinux%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B9%8BDPKG%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;dpkg 是Debian Packager的简写。为 Debian专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自 Debian 的 Linux 发行版都使用 dpkg ，例如 Ubuntu、Knoppix等，当然也需要超级用户权限操作 。 &emsp;&emsp;语法 1dpkg (选项) (参数) &emsp;&emsp;选项 12345678-i：安装软件包；-r：删除软件包；-P：删除软件包的同时删除其配置文件；-L：显示于软件包关联的文件；-l：显示已安装软件包列表；--unpack：解开软件包；-c：显示软件包内文件列表；--confiugre：配置软件包。 &emsp;&emsp;参数 1234567891011Deb软件包：指定要操作的.deb软件包。dpkg -i package.deb #安装包dpkg -r package #删除包dpkg -P package #删除包（包括配置文件）dpkg -L package #列出与该包关联的文件dpkg -l package #显示该包的版本dpkg --unpack package.deb #解开deb包的内容dpkg -S keyword #搜索所属的包内容dpkg -l #列出当前已安装的包dpkg -c package.deb #列出deb包的内容dpkg --configure package #配置包 &emsp;&emsp;apt-get命令是Debian Linux发行版中的APT软件包管理工具，又名Advanced Package Tool；所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。 Apt-get成名的原因之一在于其出色的解决软件依赖关系的能力。其通常使用.deb-formatted文件，但经过修改后可以使用apt-rpm处理红帽的Package Manager（RPM）文件。 &emsp;&emsp;使用apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。/etc/apt/sources.list是存放这些地址列表的配置文件，其格式如下： 1deb [web或ftp地址] [发行版名字] [main/contrib/non-free] &emsp;&emsp;比如在Ubuntu上更换阿里云源 123456789101112131415sudo cp sources.list sources.list.bak #备份sudo sh -c "cat &gt; /etc/apt/sources.list &lt;&lt; EOF deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse EOF" #更新源sudo apt-get update #更新列表 &emsp;&emsp;用法： 1234567891011apt-get install packagename #安装一个新软件包apt-get remove packagename #卸载一个已安装的软件包（保留配置文件）apt-get –purge remove packagename #卸载一个已安装的软件包（删除配置文件）apt-get autoclean apt #删除已经删掉的软件apt-get clean #安装的软件的备份也删除apt-get upgrade #更新所有已安装的软件包apt-get dist-upgrade #将系统升级到新版本apt-cache search package #搜索软件包apt-cache show package #获取包的相关信息，如说明、大小、版本等sudo apt-get -f install #修复依赖问题apt-get source package #下载该包的源代码 &emsp;&emsp;在某些情况下，不希望 Ubuntu 电脑连外网，通过本地离线安装各种软件，从而需要制作离线包 12sudo rm -rf /var/cache/apt/archives/* # 清空缓存目录，这一步也可以不做sudo apt-get -d install &lt;包名&gt; #需要的包及依赖都会下载到 /var/cache/apt/archives &emsp;&emsp;创建包缓存目录 12sudo mkdir /var/debssudo cp -r /var/cache/apt/archives/* /var/debs/ #将包文件全部复制到/var/debs目录下 &emsp;&emsp;生成包索引文件 1234sudo touch /var/debs/Packages.gzsudo chmod -R 777 /var/debs/ # 获得文件的可写可读可执行权限，否则后面会失败sudo dpkg-scanpackages debs /dev/null | gzip &gt; debs/Packages.gz # 创建索引tar zcvf debs.tar.gz /var/debs/* #打包文件 &emsp;&emsp;至此，离线包已经制作完成，可拷贝到其他的 Ubuntu 机器上进行离线安装，如下： 1234567tar zxvf debs.tar.gz /var/debs #解压文件sudo cp sources.list sources.list.bak #备份sudo sh -c "cat &gt; /etc/apt/sources.list &lt;&lt; EOF deb file:/var debs/EOF" #更改源sudo apt-get update #更改索引sudo apt-get install &lt;包名&gt; #安装包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>DPKG</tag>
        <tag>apt-get</tag>
        <tag>Debian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux包管理器之RPM]]></title>
    <url>%2F2018%2F08%2F13%2FLinux%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E4%B9%8BRPM%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;常言道，工欲善其事必先利其器，在使用不同 Linux 发行版的时候，安装软件的方式也大有不同，不过殊途同归，有一种方式能够适用所有的 Linux 发行版， 那就是源码编译安装；而本篇主要记录的是 Red Hat 系列发行版常用的安装方式： RPM包管理器。 &emsp;&emsp;RPM 是 Red Hat Package Manager的缩写，本意是Red Hat 软件包管理 ,在 Redhat、CentOS、Fedora、SuSE、YellowDog等主流发行版本，以及在这些版本基础上二次开发出来的发行版采用，注意 rpm 需要超级用户权限 。 &emsp;&emsp;语法 1rpm (选项) (参数) &emsp;&emsp;选项 1234567891011121314151617-a：查询所有套件；-b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+：设置包装套件的完成阶段，并指定套件档的文件名称；-c：只列出组态配置文件，本参数需配合"-l"参数使用；-d：只列出文本文件，本参数需配合"-l"参数使用；-e&lt;套件档&gt;或--erase&lt;套件档&gt;：删除指定的套件；-f&lt;文件&gt;+：查询拥有指定文件的套件；-h或--hash：套件安装时列出标记；-i：显示套件的相关信息；-i&lt;套件档&gt;或--install&lt;套件档&gt;：安装指定的套件档；-l：显示套件的文件列表；-p&lt;套件档&gt;+：查询指定的RPM套件档；-q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户；-R：显示套件的关联性信息；-s：显示文件状态，本参数需配合"-l"参数使用；-U&lt;套件档&gt;或--upgrade&lt;套件档&gt;：升级指定的套件档；-v：显示指令执行过程；-vv：详细显示指令执行过程，便于排错。 &emsp;&emsp;参数 1软件包：指定要操纵的rpm软件包。 &emsp;&emsp;安装一个 rpm 包可使用如下命令： 1rpm -ivh package.rpm &emsp;&emsp;卸载 rpm 软件包，使用命令rpm -e包名，包名可以包含版本号等信息，但是不可以有后缀.rpm，比如卸载软件包proftpd-1.2.8-1，可以使用下列格式： 1234rpm -e proftpd-1.2.8-1rpm -e proftpd-1.2.8rpm -e proftpd-rpm -e proftpd &emsp;&emsp;列出系统中安装的rpm包 1rpm -qa &emsp;&emsp;查找安装过的包 1rpm -qa | grep packagename //管道 + grep + 正则表达式 &emsp;&emsp;Yum（Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装，同样需要超级用户权限。 &emsp;&emsp;语法 1yum (选项) (参数) &emsp;&emsp;选项 123456789-h：显示帮助信息；-y：对所有的提问都回答“yes”；-c：指定配置文件；-q：安静模式；-v：详细模式；-d：设置调试等级（0-10）；-e：设置错误等级（0-10）；-R：设置yum处理一个命令的最大等待时间；-C：完全从缓存中运行，而不去下载或者更新任何头文件。 &emsp;&emsp;参数 12345678910111213install：安装rpm软件包；update：更新rpm软件包；check-update：检查是否有可用的更新rpm软件包；remove：删除指定的rpm软件包；list：显示软件包的信息；search：检查软件包的信息；info：显示指定的rpm软件包的描述信息和概要信息；clean：清理yum过期的缓存；shell：进入yum的shell提示符；resolvedep：显示rpm软件包的依赖关系；localinstall：安装本地的rpm软件包；localupdate：显示本地rpm软件包进行更新；deplist：显示rpm软件包的所有依赖关系。 &emsp;&emsp;安装 123yum install #全部安装yum install package1 #安装指定的安装包package1yum groupinsall group1 #安装程序组group1 &emsp;&emsp;更新和升级 12345yum update #全部更新yum update package1 #更新指定程序包package1yum check-update #检查可更新的程序yum upgrade package1 #升级指定程序包package1yum groupupdate group1 #升级程序组group1 &emsp;&emsp;查找和显示 1234yum info package1 #显示安装包信息package1yum list #显示所有已经安装和可以安装的程序包yum list package1 #显示指定程序包安装情况package1yum groupinfo group1 #显示程序组group1信息yum search string 根据关键字string查找安装包 &emsp;&emsp;删除程序 123yum remove package1 #删除程序包package1yum groupremove group1 #删除程序组group1yum deplist package1 #查看程序package1依赖情况 &emsp;&emsp;清除缓存 123yum clean packages #清除缓存目录下的软件包yum clean headers #清除缓存目录下的 headersyum clean oldheaders #清除缓存目录下旧的 headers &emsp;&emsp;yum的配置及换源 &emsp;&emsp;yum 的配置文件分为main 和repository ： &emsp;&emsp;&emsp;1.main:定义了全局配置选项，该文件只有一个。通常位于 /etc/yum.conf &emsp;&emsp;&emsp;2.repository:定义了源服务器的具体配置，可能是一或多个。通常位于 /etc/yum.repo.d 目录 &emsp;&emsp;&emsp;&emsp;备份初始源 1mv /etc/yum.repos.d/CentOS-Base.rpeo /etc/yum.repos.d/CentOS-Base.repo.bak &emsp;&emsp;&emsp;&emsp;换阿里云 yum 源 123wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repoyum clean allyum makecache &emsp;&emsp;&emsp;&emsp;换网易163源 123wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repoyum clean all yum makecache &emsp;&emsp;&emsp;配置ELEP源 123yum -y install epel-releaseyum clean allyum makecache &emsp;&emsp;DNF是新一代的 rpm 软件包管理器。他首先出现在 Fedora 18 这个发行版中。而最近，它取代了yum，正式成为 Fedora 22 的包管理器。 &emsp;&emsp;DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。DNF使用 RPM, libsolv 和 hawkey 库进行包管理操作。尽管它没有预装在 CentOS 和 RHEL 7 中，但你可以在使用 YUM 的同时使用 DNF 。 &emsp;&emsp;安装 DNF 包管理器 12yum install epel-releaseyum install dnf &emsp;&emsp;查看系统中可用的 DNF 软件库 12dnf repolistdnf repolist all //所有的库 &emsp;&emsp;列出所有的 rpm 包 123456789101112dnf listdnf list installed //列出所有安装的 rpm 包dnf list available //可用的 rpm 包dnf search nano //搜索包dnf provides /bin/bash //查找文件的提供者dnf install nano //安装软件包dnf update systemd //升级软件包dnf update 或 # dnf upgrade //升级系统中所有有可用升级的软件包dnf remove nano //删除软件包dnf autoremove //自动移除这些没用的孤立软件包dnf clean all //删除缓存的无用软件包dnf reinstall nano //重新安装特定软件包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RPM</tag>
        <tag>yum</tag>
        <tag>dnf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[head命令和tail命令的简单实现]]></title>
    <url>%2F2018%2F08%2F10%2Fhead%E5%91%BD%E4%BB%A4%E5%92%8Ctail%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在 Linux 上通常可以使用 head 命令和 tail 命令来查看文件的内容，head 默认显示文件的前 10 行，tail 默认显示文件尾 10 行，此篇对 head 和 tail 进行简单的实现。 &emsp;&emsp;首先说一下实现的思路，head、tail 二者类似，知其一则知其二。在实现myhead中命令行的参数有两个或者三个，两个参数是命令加文件，数字省略（默认为10）；三个参数是命令加数字(N)加文件，数字 N 代表要显示的行数，为正则显示文件前 N 行，若 N 大于文件行数，显示文件全部内容；数字 N 为负，则显示文件前 M 行(总行数减去 N 的绝值)，若 M 为负则显示空。 &emsp;&emsp;在使用 fopen 读取文件之前，先判断文件是否存在，文件是否为目录；然后使用 fgets 一次读取一行，使用 feof 判断是否到达文件末尾，以此来获取文件的总行数；然后根据命令行参数决定要显示的行数，再次调用fopen 读文件，fgets 读一行，并用 printf 输出缓冲区。以上就是实现的简单逻辑。 &emsp;&emsp;myhead.c 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/fcntl.h&gt;#define BUFSIZE 4096#define LEN 10//打印文件void print_file(const char *pathname, int len);//获取文件长度int get_lines(const char *pathname);//判断文件是否为目录，为目录返回1，不为目录返回0int get_type(const char *pathname);int main(int argc, char *argv[])&#123; int len; if(argc == 1) &#123; fprintf(stderr, "\e[36mUsage: %s filename or %s number filename.\e[0m\n", argv[0], argv[0]); fprintf(stderr, "\e[33mAnd you have no file to head!\e[0m\n"); exit(1); &#125; if(argc == 2) &#123; len = LEN; print_file(argv[1], len); &#125; if(argc == 3) &#123; len = atoi(argv[1]); print_file(argv[2], len); &#125; if(argc &gt; 3) &#123; fprintf(stderr, "\e[35mUsage: %s filename OR %s number filename\e[0m\n", argv[0], argv[0]); exit(1); &#125; exit(1);&#125;void print_file(const char *pathname, int len)&#123; int i = 0, n; FILE *fp; char buf[BUFSIZE]; n = get_lines(pathname); if(len &lt; 0) &#123; len = -len; if(len &gt; n) &#123; exit(1); &#125; len = n - len; &#125; fp = fopen(pathname, "r"); if(fp == NULL) &#123; perror(pathname); exit(1); &#125; while(!feof(fp)) &#123; if(i &lt;= len) &#123; printf("%s", buf); fgets(buf, BUFSIZE, fp); i++; &#125; else &#123; exit(1); &#125; &#125; fclose(fp);&#125;int get_lines(const char *pathname)&#123; int n = 0, flag; FILE *fp; char buf[BUFSIZE]; if(access(pathname, F_OK)) &#123; perror(pathname); exit(1); &#125; flag = get_type(pathname); if(flag) &#123; fprintf(stderr,"Error: %s is a diretory!\n", pathname); exit(1); &#125; fp = fopen(pathname, "r"); if(fp == NULL) &#123; perror(pathname); exit(1); &#125; fgets(buf, BUFSIZE, fp); while(!feof(fp)) &#123; n++; fgets(buf, BUFSIZE, fp); &#125; fclose(fp); return n;&#125;int get_type(const char *pathname)&#123; struct stat st_buf; if(lstat(pathname, &amp;st_buf) &lt; 0) &#123; perror(pathname); exit(1); &#125; if(S_ISDIR(st_buf.st_mode)) &#123; return 1; &#125; else return 0;&#125; &emsp;&emsp;示例： &emsp;&emsp;mytail 命令行参数数字(N)为正代表 tail -n N file，为负则代表 tail N file，其他逻辑和 head 一样；本篇没有实现 tail -f 动态查看文件，只是实现其简单功能。 &emsp;&emsp;myhead.c 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/fcntl.h&gt;#define BUFSIZE 4096#define LEN -10//打印文件void print_file(const char *pathname, int len);//获取文件长度int get_lines(const char *pathname);//判断文件是否为目录，为目录返回1，不为目录返回0int get_type(const char *pathname);int main(int argc, char *argv[])&#123; int len; if(argc == 1) &#123; fprintf(stderr, "\e[36mUsage: %s filename or %s number filename.\e[0m\n", argv[0], argv[0]); fprintf(stderr, "\e[33mAnd you have no file to head!\e[0m\n"); exit(1); &#125; if(argc == 2) &#123; len = LEN; print_file(argv[1], len); &#125; if(argc == 3) &#123; len = atoi(argv[1]); print_file(argv[2], len); &#125; if(argc &gt; 3) &#123; fprintf(stderr, "\e[35mUsage: %s filename OR %s number filename\e[0m\n", argv[0], argv[0]); exit(1); &#125; exit(1);&#125;void print_file(const char *pathname, int len)&#123; int i = 0, n; FILE *fp; char buf[BUFSIZE]; n = get_lines(pathname); if(len &gt; 0) &#123; if(len &gt; n) exit(1); &#125; else &#123; len += n; &#125; fp = fopen(pathname, "r"); if(fp == NULL) &#123; perror(pathname); exit(1); &#125; while(!feof(fp)) &#123; if(i &lt;= len) &#123; fgets(buf, BUFSIZE, fp); i++; &#125; else &#123; printf("%s", buf); fgets(buf, BUFSIZE, fp); i++; &#125; &#125; fclose(fp);&#125;int get_lines(const char *pathname)&#123; int n = 0, flag; FILE *fp; char buf[BUFSIZE]; if(access(pathname, F_OK)) &#123; perror(pathname); exit(1); &#125; flag = get_type(pathname); if(flag) &#123; fprintf(stderr,"Error: %s is a diretory!\n", pathname); exit(1); &#125; fp = fopen(pathname, "r"); if(fp == NULL) &#123; perror(pathname); exit(1); &#125; fgets(buf, BUFSIZE, fp); while(!feof(fp)) &#123; n++; fgets(buf, BUFSIZE, fp); &#125; fclose(fp); return n;&#125;int get_type(const char *pathname)&#123; struct stat st_buf; if(lstat(pathname, &amp;st_buf) &lt; 0) &#123; perror(pathname); exit(1); &#125; if(S_ISDIR(st_buf.st_mode)) &#123; return 1; &#125; else return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux终端使用Shadowsocks和proxychains实现代理科学上网]]></title>
    <url>%2F2018%2F08%2F09%2FLinux%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8Shadowsocks%E5%92%8Cproxychains%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;通常在 Windows 或者 Linux 图形界面上有很多方法实现科学上网，但很多时候在 Linux 终端的字符界面也有科学上网的需求，比如安装源在国外的软件，此篇介绍在终端字符界面上实现科学上网。 &emsp;&emsp;首先你需要有能够翻墙的 SSR 服务端，本站介绍过 SSR 服务端安装教程，在此不做赘述。 &emsp;&emsp;首先通过 pip 安装 shadowsocks ，以 CentOS 为例，Ubuntu过程类似： 12sudo yum install python-pipsudo pip install shadowsocks &emsp;&emsp;配置 shadowsocks.json 文件(没有则自行创建)： 1sudo vim /etc/shadowsocks.json 123456789&#123;"server":"6x.6x.6x.6x", //SSR 服务器 IP"server_port":666, //SSR 服务器 端口"local_port":1080,"password":"MyPassWord", //SSR 账号密码"timeout":600,"method":"aes-256-cfb" // 协议&#125;//根据你的 SSR 服务器账号进行设置 &emsp;&emsp;启动 ss 客户端： 1234root@zhenyan:/home/deepcam# sslocal -c /etc/shadowsocks.json -d startINFO: loading config from /etc/shadowsocks.json2018-08-09 10:35:54 INFO loading libcrypto from libcrypto.so.1.0.0started &emsp;&emsp;启动之后，本地会监听一个tcp的1080端口和一个udp的1080端口 123root@zhenyan:/home/deepcam# ss -lntup|grep sslocaltcp UNCONN 0 0 127.0.0.1:1080 *:* users:(("sslocal",13289,5))tcp LISTEN 0 1024 127.0.0.1:1080 *:* users:(("sslocal",13289,4)) &emsp;&emsp;安装配置proxychains实现代理 ： &emsp;&emsp;Ubuntu 可直接使用 apt-get 安装 1sudo apt-get install -y proxychains &emsp;&emsp;CentOS 需要进行源码编译安装 1234git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configuremake &amp;&amp; make install &emsp;&emsp;编辑配置文件 12cp ./src/proxychains.conf /etc/proxychains.conf //提取配置文件，Ubuntu是不需要这一步的vim /etc/proxychains.conf &emsp;&emsp;注释最后一行 1#socks4 127.0.0.1 9050 &emsp;&emsp;末尾新增一行 1socks5 127.0.0.1 1080 &emsp;&emsp;proxychains 的使用方式非常简单，直接在应用程序前加上 proxychains4 即可，Ubuntu 上用 apt-get 安装的话直接在应用程序前加上 proxychains &emsp;&emsp;测试梯子 123456789101112root@zhenyan:/home/deepcam# proxychains curl https://google.comProxyChains-3.1 (http://proxychains.sf.net)|DNS-request| google.com|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK|DNS-response| google.com is 216.58.194.174|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-216.58.194.174:443-&lt;&gt;&lt;&gt;-OK&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;301 Moved&lt;/H1&gt;The document has moved&lt;A HREF="https://www.google.com/"&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt; 1234567root@zhenyan:/home/deepcam# proxychains curl ip.cnProxyChains-3.1 (http://proxychains.sf.net)|DNS-request| ip.cn|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-4.2.2.2:53-&lt;&gt;&lt;&gt;-OK|DNS-response| ip.cn is 104.16.24.88|S-chain|-&lt;&gt;-127.0.0.1:1080-&lt;&gt;&lt;&gt;-104.16.24.88:80-&lt;&gt;&lt;&gt;-OK当前 IP：47.91.229.250 来自：香港特别行政区 阿里云 &emsp;&emsp;可以正常进行代理和翻墙。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSR</tag>
        <tag>proxychains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM虚拟机磁盘LVM扩容]]></title>
    <url>%2F2018%2F08%2F07%2FKVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98LVM%E6%89%A9%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 在使用 KVM 虚拟机时，可能由于事先需求不明确或者其他原因导致磁盘不够用，此时我们就需要对磁盘进行拓展，本人遇到这个问题时在 CentOS7 上，而且在此kvm中 CentoOS7 分区默认是做了 LVM 的，可先在图形界面上对其增加一块磁盘。 &emsp;&emsp;而且在图形界面删除磁盘的时候，是可以对其进行恢复的，本人碰巧删掉一个启动磁盘后系统无法正常开机，而后添加回去后系统恢复正常。 &emsp;&emsp;添加磁盘后，首先使用 fdisk -l 查看磁盘是否添加上去，若没有看到新增的磁盘，可能需要重启服务器。 &emsp;&emsp;看到新增磁盘后( /dev/sdb )，使用 fdisk /dev/sdb 对其进行分区； &emsp;&emsp;其中 8e 代表文件系统为 LVM，然后我们创建 PV 12[root@localhost ~]# pvcreate /dev/sdb1 Physical volume &quot;/dev/sdb1&quot; successfully created &emsp;&emsp;拓展VG，事先得用 vgdispaly 确定要拓展的 vg 12[root@localhost ~]# vgextend VolGroup /dev/sdb1 Volume group &quot;VolGroup&quot; successfully extend &emsp;&emsp;拓展 LV，事先也需要使用 lvdisplay 确定要拓展得 lv(lv_root原来为50G，这里拓展50G) 123[root@localhost ~]# lvcreate -L 50G -n /dev/VolGroup/lv_root Extending logical volume lv_root to 100.00 GiB Logical volume lv_root successfully resized &emsp;&emsp;注意，此时我们需要重新获取 lv_root 的大小，在 CentOS 7 上多数使用的 xfs，因此需要使用 xfs_growfs ，若 lv_root 使用的是 ext3、ext4 的话则使用 resize2fs， 最后使用 df 查看 12xfs_growfs /dev/VolGroup/lv_rootdf -h &emsp;&emsp;至此已经完成了 kvm 虚拟机磁盘 LVM 扩容。 &emsp;&emsp;顺便说一下 LVM 逻辑卷管理器以及 PE、PV、VG、LV 相关的内容。 &emsp;&emsp;LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。 &emsp;&emsp;LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。 &emsp;&emsp;LVM的工作原理其实很简单，它就是通过将底层的物理硬盘抽象的封装起来，然后以逻辑卷的方式呈现给上层应用。在传统的磁盘管理机制中，我们的上层应用是直接访问文件系统，从而对底层的物理硬盘进行读取，而在LVM中，其通过对底层的硬盘进行封装，当我们对底层的物理硬盘进行操作时，其不再是针对于分区进行操作，而是通过一个叫做逻辑卷的东西来对其进行底层的磁盘管理操作。比如说我增加一个物理硬盘，这个时候上层的服务是感觉不到的，因为呈现给上层服务的是以逻辑卷的方式。 &emsp;&emsp;LVM最大的特点就是可以对磁盘进行动态管理。因为逻辑卷的大小是可以动态调整的，而且不会丢失现有的数据。如果我们新增加了硬盘，其也不会改变现有上层的逻辑卷。作为一个动态磁盘管理机制，逻辑卷技术大大提高了磁盘管理的灵活性。 &emsp;&emsp; 物理卷—–PV（Physical Volume）&emsp;&emsp;物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘。 &emsp;&emsp; 卷组——–VG（Volumne Group）&emsp;&emsp;卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。 &emsp;&emsp; 逻辑卷—–LV（Logical Volume）&emsp;&emsp;逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷要以属于同一个卷组，也可以属于不同的多个卷组。 &emsp;&emsp;物理区域–PE（Physical Extent） &emsp;&emsp;物理区域是物理卷中可用于分配的最小存储单元，物理区域的大小可根据实际情况在建立物理卷时指定。物理区域大小一旦确定将不能更改，同一卷组中的所有物理卷的物理区域大小需要一致。 &emsp;&emsp;逻辑区域―LE（Logical Extent） &emsp;&emsp;逻辑区域是逻辑卷中可用于分配的最小存储单元，逻辑区域的大小取决于逻辑卷所在卷组中的物理区域的大小。 &emsp;&emsp;卷组描述区域—–（Volume Group Descriptor Area） &emsp;&emsp;卷组描述区域存在于每个物理卷中，用于描述物理卷本身、物理卷所属卷组、卷组中的逻辑卷及逻辑卷中物理区域的分配等所有信息，卷组描述区域是在使用pvcreate建立物理卷时建立的。 &emsp;&emsp;关系图如下：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>KVM</tag>
        <tag>LVM</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报任安书--司马迁]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%8A%A5%E4%BB%BB%E5%AE%89%E4%B9%A6-%E5%8F%B8%E9%A9%AC%E8%BF%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;太史公牛马走司马迁再拜言。 &emsp;&emsp;少卿足下：曩者辱赐书，教以慎于接物，推贤进士为务。意气勤勤恳恳，若望仆不相师，而用流俗人之言，仆非敢如此也。请略陈固陋。阙然久不报，幸勿为过。 &emsp;&emsp;仆之先人非有剖符丹书之功，文史星历，近乎卜祝之间，固主上所戏弄，倡优所畜，流俗之所轻也。假令仆伏法受诛，若九牛亡一毛，与蝼蚁何以异？而世又不与能死节者比，特以为智穷罪极，不能自免，卒就死耳。何也？素所自树立使然。人固有一死，或重于泰山，或轻于鸿毛，用之所趋异也。太上不辱先，其次不辱身，其次不辱理色，其次不辱辞令，其次诎体受辱，其次易服受辱，其次关木索、被箠楚受辱，其次剔毛发、婴金铁受辱，其次毁肌肤、断肢体受辱，最下腐刑极矣！传曰：“刑不上大夫。”此言士节不可不勉励也。猛虎在深山，百兽震恐，及在槛阱之中，摇尾而求食，积威约之渐也。故士有画地为牢，势不可入；削木为吏，议不可对，定计于鲜也。今交手足，受木索，暴肌肤，受榜箠，幽于圜墙之中。当此之时，见狱吏则头枪地，视徒隶则心惕息。何者？积威约之势也。及以至是，言不辱者，所谓强颜耳，曷足贵乎！且西伯，伯也，拘于羑里；李斯，相也，具于五刑；淮阴，王也，受械于陈；彭越、张敖，南向称孤，系狱具罪；绛侯诛诸吕，权倾五伯，囚于请室；魏其，大将也，衣赭衣、关三木；季布为朱家钳奴；灌夫受辱于居室。此人皆身至王侯将相，声闻邻国，及罪至罔加，不能引决自裁，在尘埃之中。古今一体，安在其不辱也？由此言之，勇怯，势也；强弱，形也。审矣，何足怪乎？夫人不能早自裁绳墨之外，以稍陵迟，至于鞭箠之间，乃欲引节，斯不亦远乎！古人所以重施刑于大夫者，殆为此也。 &emsp;&emsp;夫人情莫不贪生恶死，念父母，顾妻子；至激于义理者不然，乃有所不得已也。今仆不幸，早失父母，无兄弟之亲，独身孤立，少卿视仆于妻子何如哉？且勇者不必死节，怯夫慕义，何处不勉焉！仆虽怯懦，欲苟活，亦颇识去就之分矣，何至自沉溺缧绁之辱哉！且夫臧获婢妾，犹能引决，况若仆之不得已乎？所以隐忍苟活，幽于粪土之中而不辞者，恨私心有所不尽，鄙陋没世，而文采不表于后也。 &emsp;&emsp; 古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，此皆圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策以舒其愤，思垂空文以自见。 &emsp;&emsp;仆窃不逊，近自托于无能之辞，网罗天下放失旧闻，略考其行事，综其终始，稽其成败兴坏之纪，上计轩辕，下至于兹，为十表，本纪十二，书八章，世家三十，列传七十，凡百三十篇。亦欲以究天人之际，通古今之变，成一家之言。草创未就，会遭此祸，惜其不成，是以就极刑而无愠色。仆诚以著此书，藏之名山，传之其人，通邑大都，则仆偿前辱之责，虽万被戮，岂有悔哉？然此可为智者道，难为俗人言也！ &emsp;&emsp;且负下未易居，下流多谤议。仆以口语遇遭此祸，重为乡党所笑，以污辱先人，亦何面目复上父母之丘墓乎？虽累百世，垢弥甚耳！是以肠一日而九回，居则忽忽若有所亡，出则不知其所如往。每念斯耻，汗未尝不发背沾衣也。身直为闺阁之臣，宁得自引深藏于岩穴邪！故且从俗浮沉，与时俯仰，以通其狂惑。今少卿乃教之以推贤进士，无乃与仆之私心剌谬乎？今虽欲自雕琢，曼辞以自饰，无益，于俗不信，适足取辱耳。要之死日，然后是非乃定。书不能悉意，故略陈固陋。 &emsp;&emsp;谨再拜。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卫将军骠骑列传--司马迁]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%8D%AB%E5%B0%86%E5%86%9B%E9%AA%A0%E9%AA%91%E5%88%97%E4%BC%A0-%E5%8F%B8%E9%A9%AC%E8%BF%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;大将军卫青者，平阳人也。其父郑季，为吏，给事平阳侯家，与侯妾卫媪通，生青。青同母兄卫长子，而姊卫子夫自平阳公主家得幸天子，故冒姓为卫氏。字仲卿。长子更字长君。长君母号为卫媪。媪长女卫孺，次女少兒，次女卫子夫。後子夫男弟步、广皆冒卫氏。 青为侯家人，少时归其父，其父使牧羊。先母之子皆奴畜之，不以为兄弟数。青尝从入至甘泉居室，有一钳徒相青曰：“贵人也，官至封侯。”青笑曰：“人奴之生，得毋笞骂即足矣，安得封侯事乎！” 青壮，为侯家骑，从平阳主。建元二年春，青姊子夫得入宫幸上。皇后，堂邑大长公主女也，无子，妒。大长公主闻卫子夫幸，有身，妒之，乃使人捕青。青时给事建章，未知名。大长公主执囚青，欲杀之。其友骑郎公孙敖与壮士往篡取之，以故得不死。上闻，乃召青为建章监，侍中，及同母昆弟贵，赏赐数日间累千金。孺为太仆公孙贺妻。少兒故与陈掌通，上召贵掌。公孙敖由此益贵。子夫为夫人。青为大中大夫。 元光五年，青为车骑将军，击匈奴，出上谷；太仆公孙贺为轻车将军，出云中；大中大夫公孙敖为骑将军，出代郡；卫尉李广为骁骑将军，出雁门：军各万骑。青至茏城，斩首虏数百。骑将军敖亡七千骑；卫尉李广为虏所得，得脱归：皆当斩，赎为庶人。贺亦无功。 元朔元年春，卫夫人有男，立为皇后。其秋，青为车骑将军，出雁门，三万骑击匈奴，斩首虏数千人。明年，匈奴入杀辽西太守，虏略渔阳二千馀人，败韩将军军。汉令将军李息击之，出代；令车骑将军青出云中以西至高阙。遂略河南地，至于陇西，捕首虏数千，畜数十万，走白羊、楼烦王。遂以河南地为朔方郡。以三千八百户封青为长平侯。青校尉苏建有功，以千一百户封建为平陵侯。使建筑朔方城。青校尉张次公有功，封为岸头侯。天子曰：“匈奴逆天理，乱人伦，暴长虐老，以盗窃为务，行诈诸蛮夷，造谋藉兵，数为边害，故兴师遣将，以征厥罪。诗不云乎，“薄伐玁狁，至于太原”，“出车彭彭，城彼朔方”。今车骑将军青度西河至高阙，获首虏二千三百级，车辎畜产毕收为卤，已封为列侯，遂西定河南地，按榆谿旧塞，绝梓领，梁北河，讨蒲泥，破符离，斩轻锐之卒，捕伏听者三千七十一级，执讯获丑，驱马牛羊百有馀万，全甲兵而还，益封青三千户。”其明年，匈奴入杀代郡太守友，入略雁门千馀人。其明年，匈奴大入代、定襄、上郡，杀略汉数千人。 其明年，元朔之五年春，汉令车骑将军青将三万骑，出高阙；卫尉苏建为游击将军，左内史李沮为彊弩将军，太仆公孙贺为骑将军，代相李蔡为轻车将军，皆领属车骑将军，俱出朔方；大行李息、岸头侯张次公为将军，出右北平：咸击匈奴。匈奴右贤王当卫青等兵，以为汉兵不能至此，饮醉。汉兵夜至，围右贤王，右贤王惊，夜逃，独与其爱妾一人壮骑数百驰，溃围北去。汉轻骑校尉郭成等逐数百里，不及，得右贤裨王十馀人，众男女万五千馀人，畜数千百万，於是引兵而还。至塞，天子使使者持大将军印，即军中拜车骑将军青为大将军，诸将皆以兵属大将军，大将军立号而归。天子曰：“大将军青躬率戎士，师大捷，获匈奴王十有馀人，益封青六千户。”而封青子伉为宜春侯，青子不疑为阴安侯，青子登为发干侯。青固谢曰：“臣幸得待罪行间，赖陛下神灵，军大捷，皆诸校尉力战之功也。陛下幸已益封臣青。臣青子在唡褓中，未有勤劳，上幸列地封为三侯，非臣待罪行间所以劝士力战之意也。伉等三人何敢受封！”天子曰：“我非忘诸校尉功也，今固且图之。”乃诏御史曰：“护军都尉公孙敖三从大将军击匈奴，常护军，傅校获王，以千五百户封敖为合骑侯。都尉韩说从大将军出窳浑，至匈奴右贤王庭，为麾下搏战获王，以千三百户封说为龙嵒侯。骑将军公孙贺从大将军获王，以千三百户封贺为南窌侯。轻车将军李蔡再从大将军获王，以千六百户封蔡为乐安侯。校尉李朔，校尉赵不虞，校尉公孙戎奴，各三从大将军获王，以千三百户封朔为涉轵侯，以千三百户封不虞为随成侯，以千三百户封戎奴为从平侯。将军李沮、李息及校尉豆如意有功，赐爵关内侯，食邑各三百户。”其秋，匈奴入代，杀都尉硃英。 其明年春，大将军青出定襄，合骑侯敖为中将军，太仆贺为左将军，翕侯赵信为前将军，卫尉苏建为右将军，郎中令李广为後将军，右内史李沮为彊弩将军，咸属大将军，斩首数千级而还。月馀，悉复出定襄击匈奴，斩首虏万馀人。右将军建、前将军信并军三千馀骑，独逢单于兵，与战一日馀，汉兵且尽。前将军故胡人，降为翕侯，见急，匈奴诱之，遂将其馀骑可八百，饹降单于。右将军苏建尽亡其军，独以身得亡去，自归大将军。大将军问其罪正闳、长史安、议郎周霸等：“建当云何？”霸曰：“自大将军出，未尝斩裨将。今建弃军，可斩以明将军之威。”闳、安曰：“不然。兵法“小敌之坚，大敌之禽也”。今建以数千当单于数万，力战一日馀，士尽，不敢有二心，自归。自归而斩之，是示後无反意也。不当斩。”大将军曰：“青幸得以肺腑待罪行间，不患无威，而霸说我以明威，甚失臣意。且使臣职虽当斩将，以臣之尊宠而不敢自擅专诛於境外，而具归天子，天子自裁之，於是以见为人臣不敢专权，不亦可乎？”军吏皆曰“善”。遂囚建诣行在所。入塞罢兵。 是岁也，大将军姊子霍去病年十八，幸，为天子侍中。善骑射，再从大将军，受诏与壮士，为剽姚校尉，与轻勇骑八百直弃大军数百里赴利，斩捕首虏过当。於是天子曰：“剽姚校尉去病斩首虏二千二十八级，及相国、当户，斩单于大父行籍若侯产，生捕季父罗姑比，再冠军，以千六百户封去病为冠军侯。上谷太守郝贤四从大将军，捕斩首虏二千馀人，以千一百户封贤为众利侯。”是岁，失两将军军，亡翕侯，军功不多，故大将军不益封。右将军建至，天子不诛，赦其罪，赎为庶人。 大将军既还，赐千金。是时王夫人方幸於上，甯乘说大将军曰：“将军所以功未甚多，身食万户，三子皆为侯者，徒以皇后故也。今王夫人幸而宗族未富贵，原将军奉所赐千金为王夫人亲寿。”大将军乃以五百金为寿。天子闻之，问大将军，大将军以实言，上乃拜甯乘为东海都尉。 张骞从大将军，以尝使大夏，留匈奴中久，导军，知善水草处，军得以无饥渴，因前使绝国功，封骞博望侯。 冠军侯去病既侯三岁，元狩二年春，以冠军侯去病为骠骑将军，将万骑出陇西，有功。天子曰：“骠骑将军率戎士逾乌盭，讨濮，涉狐奴，历五王国，辎重人众慑慴者弗取，冀获单于子。转战六日，过焉支山千有馀里，合短兵，杀折兰王，斩卢胡王，诛全甲，执浑邪王子及相国、都尉，首虏八千馀级，收休屠祭天金人，益封去病二千户。” 其夏，骠骑将军与合骑侯敖俱出北地，异道；博望侯张骞、郎中令李广俱出右北平，异道：皆击匈奴。郎中令将四千骑先至，博望侯将万骑在後至。匈奴左贤王将数万骑围郎中令，郎中令与战二日，死者过半，所杀亦过当。博望侯至，匈奴兵引去。博望侯坐行留，当斩，赎为庶人。而骠骑将军出北地，已遂深入，与合骑侯失道，不相得，骠骑将军逾居延至祁连山，捕首虏甚多。天子曰：“骠骑将军逾居延，遂过小月氏，攻祁连山，得酋涂王，以众降者二千五百人，斩首虏三万二百级，获五王，五王母，单于阏氏、王子五十九人，相国、将军、当户、都尉六十三人，师大率减什三，益封去病五千户。赐校尉从至小月氏爵左庶长。鹰击司马破奴再从骠骑将军斩濮王，捕稽沮王，千骑将得王、王母各一人，王子以下四十一人，捕虏三千三百三十人，前行捕虏千四百人，以千五百户封破奴为从骠侯。校尉句王高不识，从骠骑将军捕呼于屠王王子以下十一人，捕虏千七百六十八人，以千一百户封不识为宜冠侯。校尉仆多有功，封为煇渠侯。”合骑侯敖坐行留不与骠骑会，当斩，赎为庶人。诸宿将所将士马兵亦不如骠骑，骠骑所将常选，然亦敢深入，常与壮骑先其大军，军亦有天幸，未尝困绝也。然而诸宿将常坐留落不遇。由此骠骑日以亲贵，比大将军。 其秋，单于怒浑邪王居西方数为汉所破，亡数万人，以骠骑之兵也。单于怒，欲召诛浑邪王。浑邪王与休屠王等谋欲降汉，使人先要边。是时大行李息将城河上，得浑邪王使，即驰传以闻。天子闻之，於是恐其以诈降而袭边，乃令骠骑将军将兵往迎之。骠骑既渡河，与浑邪王众相望。浑邪王裨将见汉军而多欲不降者，颇遁去。骠骑乃驰入与浑邪王相见，斩其欲亡者八千人，遂独遣浑邪王乘传先诣行在所，尽将其众渡河，降者数万，号称十万。既至长安，天子所以赏赐者数十巨万。封浑邪王万户，为漯阴侯。封其裨王呼毒尼为下摩侯，鹰庇为煇渠侯，禽犁为河綦侯，大当户铜离为常乐侯。於是天子嘉骠骑之功曰：“骠骑将军去病率师攻匈奴西域王浑邪，王及厥众萌咸相饹，率以军粮接食，并将控弦万有馀人，诛獟駻，获首虏八千馀级，降异国之王三十二人，战士不离伤，十万之众咸怀集服，仍与之劳，爰及河塞，庶几无患，幸既永绥矣。以千七百户益封骠骑将军。”减陇西、北地、上郡戍卒之半，以宽天下之繇。 居顷之，乃分徙降者边五郡故塞外，而皆在河南，因其故俗，为属国。其明年，匈奴入右北平、定襄，杀略汉千馀人。 其明年，天子与诸将议曰：“翕侯赵信为单于画计，常以为汉兵不能度幕轻留，今大发士卒，其势必得所欲。”是岁元狩四年也。 元狩四年春，上令大将军青、骠骑将军去病将各五万骑，步兵转者踵军数十万，而敢力战深入之士皆属骠骑。骠骑始为出定襄，当单于。捕虏言单于东，乃更令骠骑出代郡，令大将军出定襄。郎中令为前将军，太仆为左将军，主爵赵食其为右将军，平阳侯襄为後将军，皆属大将军。兵即度幕，人马凡五万骑，与骠骑等咸击匈奴单于。赵信为单于谋曰：“汉兵既度幕，人马罢，匈奴可坐收虏耳。”乃悉远北其辎重，皆以精兵待幕北。而適值大将军军出塞千馀里，见单于兵陈而待，於是大将军令武刚车自环为营，而纵五千骑往当匈奴。匈奴亦纵可万骑。会日且入，大风起，沙砾击面，两军不相见，汉益纵左右翼绕单于。单于视汉兵多，而士马尚彊，战而匈奴不利，薄莫，单于遂乘六，壮骑可数百，直冒汉围西北驰去。时已昏，汉匈奴相纷挐，杀伤大当。汉军左校捕虏言单于未昏而去，汉军因发轻骑夜追之，大将军军因随其後。匈奴兵亦散走。迟明，行二百馀里，不得单于，颇捕斩首虏万馀级，遂至窴颜山赵信城，得匈奴积粟食军。军留一日而还，悉烧其城馀粟以归。 大将军之与单于会也，而前将军广、右将军食其军别从东道，或失道，後击单于。大将军引还过幕南，乃得前将军、右将军。大将军欲使使归报，令长史簿责前将军广，广自杀。右将军至，下吏，赎为庶人。大将军军入塞，凡斩捕首虏万九千级。 是时匈奴众失单于十馀日，右谷蠡王闻之，自立为单于。单于後得其众，右王乃去单于之号。 骠骑将军亦将五万骑，车重与大将军军等，而无裨将。悉以李敢等为大校，当裨将，出代、右北平千馀里，直左方兵，所斩捕功已多大将军。军既还，天子曰：“骠骑将军去病率师，躬将所获荤粥之士，约轻赍，绝大幕，涉获章渠，以诛比车耆，转击左大将，斩获旗鼓，历涉离侯。济弓闾，获屯头王、韩王等三人，将军、相国、当户、都尉八十三人，封狼居胥山，禅於姑衍，登临翰海。执卤获丑七万有四百四十三级，师率减什三，取食於敌，逴行殊远而粮不绝，以五千八百户益封骠骑将军。”右北平太守路博德属骠骑将军，会与城，不失期，从至檮余山，斩首捕虏二千七百级，以千六百户封博德为符离侯。北地都尉邢山从骠骑将军获王，以千二百户封山为义阳侯。故归义因淳王复陆支、楼专王伊即靬皆从骠骑将军有功，以千三百户封复陆支为壮侯，以千八百户封伊即靬为众利侯。从骠侯破奴、昌武侯安稽从骠骑有功，益封各三百户。校尉敢得旗鼓，为关内侯，食邑二百户。校尉自为爵大庶长。军吏卒为官，赏赐甚多。而大将军不得益封，军吏卒皆无封侯者。 两军之出塞，塞阅官及私马凡十四万匹，而复入塞者不满三万匹。乃益置大司马位，大将军、骠骑将军皆为大司马。定令，令骠骑将军秩禄与大将军等。自是之後，大将军青日退，而骠骑日益贵。举大将军故人门下多去事骠骑，辄得官爵，唯任安不肯。 骠骑将军为人少言不泄，有气敢任。天子尝欲教之孙吴兵法，对曰：“顾方略何如耳，不至学古兵法。”天子为治第，令骠骑视之，对曰：“匈奴未灭，无以家为也。”由此上益重爱之。然少而侍中，贵，不省士。其从军，天子为遣太官赍数十乘，既还，重车馀弃粱肉，而士有饥者。其在塞外，卒乏粮，或不能自振，而骠骑尚穿域蹋鞠。事多此类。大将军为人仁善退让，以和柔自媚於上，然天下未有称也。 骠骑将军自四年军後三年，元狩六年而卒。天子悼之，发属国玄甲军，陈自长安至茂陵，为冢象祁连山。谥之，并武与广地曰景桓侯。子嬗代侯。嬗少，字子侯，上爱之，幸其壮而将之。居六岁，元封元年，嬗卒，谥哀侯。无子，绝，国除。 自骠骑将军死後，大将军长子宜春侯伉坐法失侯。後五岁，伉弟二人，阴安侯不疑及发干侯登皆坐酎金失侯。失侯後二岁，冠军侯国除。其後四年，大将军青卒，谥为烈侯。子伉代为长平侯。 自大将军围单于之後，十四年而卒。竟不复击匈奴者，以汉马少，而方南诛两越，东伐朝鲜，击羌、西南夷，以故久不伐胡。 大将军以其得尚平阳长公主故，长平侯伉代侯。六岁，坐法失侯。 左方两大将军及诸裨将名： 最大将军青，凡七出击匈奴，斩捕首虏五万馀级。一与单于战，收河南地，遂置朔方郡，再益封，凡万一千八百户。封三子为侯，侯千三百户。并之，万五千七百户。其校尉裨将以从大将军侯者九人。其裨将及校尉已为将者十四人。为裨将者曰李广，自有传。无传者曰： 将军公孙贺。贺，义渠人，其先胡种。贺父浑邪，景帝时为平曲侯，坐法失侯。贺，武帝为太子时舍人。武帝立八岁，以太仆为轻车将军，军马邑。後四岁，以轻车将军出云中。後五岁，以骑将军从大将军有功，封为南窌侯。後一岁，以左将军再从大将军出定襄，无功。後四岁，以坐酎金失侯。後八岁，以浮沮将军出五原二千馀里，无功。後八岁，以太仆为丞相，封葛绎侯。贺七为将军，出击匈奴无大功，而再侯，为丞相。坐子敬声与阳石公主奸，为巫蛊，族灭，无後。 将军李息，郁郅人。事景帝。至武帝立八岁，为材官将军，军马邑；後六岁，为将军，出代；後三岁，为将军，从大将军出朔方：皆无功。凡三为将军，其後常为大行。 将军公孙敖，义渠人。以郎事武帝。武帝立十二岁，为骑将军，出代，亡卒七千人，当斩，赎为庶人。後五岁，以校尉从大将军有功，封为合骑侯。後一岁，以中将军从大将军，再出定襄，无功。後二岁，以将军出北地，後骠骑期，当斩，赎为庶人。後二岁，以校尉从大将军，无功。後十四岁，以因杅将军筑受降城。七岁，复以因杅将军再出击匈奴，至余吾，亡士卒多，下吏，当斩，诈死，亡居民间五六岁。後发觉，复系。坐妻为巫蛊，族。凡四为将军，出击匈奴，一侯。 将军李沮，云中人。事景帝。武帝立十七岁，以左内史为彊弩将军。後一岁，复为彊弩将军。 将军李蔡，成纪人也。事孝文帝、景帝、武帝。以轻车将军从大将军有功，封为乐安侯。已为丞相，坐法死。 将军张次公，河东人。以校尉从卫将军青有功，封为岸头侯。其後太后崩，为将军，军北军。後一岁，为将军，从大将军，再为将军，坐法失侯。次公父隆，轻车武射也。以善射，景帝幸近之也。 将军苏建，杜陵人。以校尉从卫将军青，有功，为平陵侯，以将军筑朔方。後四岁，为游击将军，从大将军出朔方。後一岁，以右将军再从大将军出定襄，亡翕侯，失军，当斩，赎为庶人。其後为代郡太守，卒，冢在大犹乡。 将军赵信，以匈奴相国降，为翕侯。武帝立十七岁，为前将军，与单于战，败，降匈奴。 将军张骞，以使通大夏，还，为校尉。从大将军有功，封为博望侯。後三岁，为将军，出右北平，失期，当斩，赎为庶人。其後使通乌孙，为大行而卒，冢在汉中。 将军赵食其，祋祤人也。武帝立二十二岁，以主爵为右将军，从大将军出定襄，迷失道，当斩，赎为庶人。 将军曹襄，以平阳侯为後将军，从大将军出定襄。襄，曹参孙也。 将军韩说，弓高侯庶孙也。以校尉从大将军有功，为龙嵒侯，坐酎金失侯。元鼎六年，以待诏为横海将军，击东越有功，为按道侯。以太初三年为游击将军，屯於五原外列城。为光禄勋，掘蛊太子宫，卫太子杀之。 将军郭昌，云中人也。以校尉从大将军。元封四年，以太中大夫为拔胡将军，屯朔方。还击昆明，毋功，夺印。 将军荀彘，太原广武人。以御见，侍中，为校尉，数从大将军。以元封三年为左将军击朝鲜，毋功。以捕楼船将军坐法死。 最骠骑将军去病，凡六出击匈奴，其四出以将军，斩捕首虏十一万馀级。及浑邪王以众降数万，遂开河西酒泉之地，西方益少胡寇。四益封，凡万五千一百户。其校吏有功为侯者凡六人，而後为将军二人。 将军路博德，平州人。以右北平太守从骠骑将军有功，为符离侯。骠骑死後，博德以卫尉为伏波将军，伐破南越，益封。其後坐法失侯。为彊弩都尉，屯居延，卒。 将军赵破奴，故九原人。尝亡入匈奴，已而归汉，为骠骑将军司马。出北地时有功，封为从骠侯。坐酎金失侯。後一岁，为匈河将军，攻胡至匈河水，无功。後二岁，击虏楼兰王，复封为浞野侯。後六岁，为浚稽将军，将二万骑击匈奴左贤王，左贤王与战，兵八万骑围破奴，破奴生为虏所得，遂没其军。居匈奴中十岁，复与其太子安国亡入汉。後坐巫蛊，族。 自卫氏兴，大将军青首封，其後枝属为五侯。凡二十四岁而五侯尽夺，卫氏无为侯者。 太史公曰：苏建语余曰：“吾尝责大将军至尊重，而天下之贤大夫毋称焉，原将军观古名将所招选择贤者，勉之哉。大将军谢曰：“自魏其、武安之厚宾客，天子常切齿。彼亲附士大夫，招贤绌不肖者，人主之柄也。人臣奉法遵职而已，何与招士！””骠骑亦放此意，其为将如此。 君子豹变，贵贱何常。青本奴虏，忽升戎行。姊配皇极，身尚平阳。宠荣斯僭，取乱彝章。嫖姚继踵，再静边方。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记(3)]]></title>
    <url>%2F2018%2F08%2F03%2FLinux%E7%AC%94%E8%AE%B0-3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; nohup command &amp; : nohup(no hang up)不挂断地运行命令。command的标准输出被自动改向到当前目录下的nohup.out文件，起到了log的作用。&amp;意味着放在后台执行，当然也可以用 Ctrl + Z 让一个运行的程序放在后台执行，fg 使其恢复到前台。 &emsp;&emsp;type可以用来判断一个命令是否为内置命令 : &emsp;&emsp;内部命令在系统启动时就调入内存，是常驻内存的，所以执行效率高。 &emsp;&emsp;外部命令是系统的软件功能，用户需要时才从硬盘中读入内存。 &emsp;&emsp;CD 切换目录( . 代表当前目录， .. 代表上级目录，根目录下 .. 和 . 都代表根目录)： cd /etc 切换到 /etc 目录 cd 回到家目录 cd ～ 切换家目录 cd - 回到之前的目录cd 回到家目录 cd .. 切换到上级目录 &emsp;&emsp;scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。 &emsp;&emsp;1.从本地复制到远程有4种方式 scp local_file remote_username@remote_ip:remote_folder scp local_file remote_username@remote_ip:remote_file scp local_file remote_ip:remote_folder scp local_file remote_ip:remote_file 1scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3 &emsp;&emsp;2.从远程复制到远程只需将 localfile 与 remote_file 调换位置即可，-P 指定端口， -r 递归复制整个目录，例 12scp -P 8888 root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 scp -r www.runoob.com:/home/root/others/ /home/space/music/ &emsp;&emsp;Linux踢除一个登录的用户：首先要获取的该用户的终端标识符，使用 w 命令即可看到，假设为 pts/n ，然后使用下面命令 1pkill -kill -t pts/n &emsp;&emsp;共享库于静态库： &emsp;&emsp;在 windows 上共享库也称作动态库，是以 .dll 为后缀名的文件，静态库则是以 .lib 为后缀名的文件。 &emsp;&emsp;在 Linux 上虽然没有后缀名的概念，但 动态库通常是以 .so 结尾的文件， 静态库是以 .a 结尾的文件。 &emsp;&emsp; Linux中命名系统中共享库的规则 &emsp;&emsp;共享库的命名 real name 主版本号+次版本号 so name 判断主版本号 link name 方便Makefile编译链接 &emsp;&emsp;静态库(.o + .a)优点是任意电脑上可运行，缺点是代码体积大。 &emsp;&emsp;动态库(.so + 符号记录表 + 依赖共享库版本)有点是代码体积小，缺点是依赖共享库版本的一致。 &emsp;&emsp;查看 Linux 的版本信息： uname -a 查看版本当前操作系统内核信息 cat /proc/version 查看当前操作系统版本信息 cat /etc/issue 或cat /etc/redhat-release 查看版本当前操作系统发行版信息 cat /proc/cpuinfo 查看cpu相关信息，包括型号、主频、内核信息等 getconf LONG_BIT 查看版本说明当前CPU运行在32还是64 bit模式下 lsb_release -a 查看系统版本 &emsp;&emsp;管道分流：tee从标准输入读入数据，并向标准输出和一个文件各发送一份数据。 1cat /etc/passwd | tee output | grep root]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cp命令的简单实现]]></title>
    <url>%2F2018%2F07%2F30%2Fcp%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;cp 即copy，顾名思义就是复制的意思；cp命令 用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。 &emsp;&emsp;本篇主要实现 cp -pf 功能，首先说下实现的思路，在单文件复制时，需要考虑四种情况： &emsp;&emsp;1.复制文件到文件，若目的文件存在则更新，不存在则创建。 &emsp;&emsp;2.复制文件到目录，若目录不存在则失败。 &emsp;&emsp;3.复制目录到文件，失败。 &emsp;&emsp;4.复制目录到目录，若目的目录不存在则失败。 &emsp;&emsp;多文件复制就是循环的单文件复制过程，然而此时有一个问题，在复制目录的时候不能单纯的和文件复制混为一谈，首先需要进入源目录，保存目录路径，然后还得进入目的目录，并创建目录，保存目录路径，再返回原目录，将其中的文件复制到目的目录的新建目录中，再返回源目录，复制其他文件；若源目录包含多重目录则需要使用递归函数调用。实现的大致思路是这样，但如果涉及到大文件，则需要加入多进程或多线程。 &emsp;&emsp;源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;//缓冲区的大小#define BUFFSZIE 4096//创建文件权限#define FILEMODE 0664//创建目录权限#define DIRMODE 0775//创建目录的最大长度#define PATHSIZE 255//错误提示输出void oops(char *, char *);//获取文件的stat结构体信息struct stat get_stat(const char *pathname);//复制文件void copy_file(char *src_str, char *des_str);//复制一个目录void copy_dir(char *src_str, char *des_str);int main(int argc, char *argv[])&#123; //获取命令行参数的属性 struct stat st_buf, src_buf, des_buf; char re_dir[PATHSIZE]; int i; //获取当前目录 getcwd(re_dir, PATHSIZE); if(argc &lt; 3) &#123; fprintf(stderr, "usage: %s source ... destination\n", *argv); &#125; //两个参数，四种情况 if(argc ==3 ) &#123; src_buf = get_stat(argv[1]); des_buf = get_stat(argv[2]); if(S_ISDIR(src_buf.st_mode) &amp;&amp; S_ISDIR(src_buf.st_mode)) copy_dir(argv[1], argv[2]); else copy_file(argv[1], argv[2]); &#125; st_buf = get_stat(argv[argc - 1]); //复制多个文件和目录 if(argc &gt; 3) &#123; if(!S_ISDIR(st_buf.st_mode)) &#123; fprintf(stderr, "%s:%s is not diretory!\n", argv[0], argv[argc-1]); exit(0); &#125; for(i = 1; i &lt; argc - 1; i++) &#123; if(access(argv[i], F_OK)) &#123; fprintf(stderr, "Error: %s is not exist!", argv[i]); exit(1); &#125; chdir(re_dir); copy_dir(argv[i], argv[argc-1]); &#125; &#125; exit(0);&#125;void oops(char *str1, char *str2)&#123; fprintf(stderr, "Error: %s", str1); perror(str2); exit(1);&#125;struct stat get_stat(const char *pathname)&#123; struct stat st_buf; if(lstat(pathname, &amp;st_buf) &lt; 0) &#123; perror("lstat"); printf("ERROR: %s\n", pathname); exit(1); &#125; return st_buf;&#125;void copy_file(char *src_str, char *des_str)&#123; int in_fd, out_fd, n_chars; struct stat st_buf; char *dir_str; char buf[BUFFSZIE]; char re_buf[PATHSIZE]; getcwd(re_buf, PATHSIZE); if((in_fd = open(src_str, O_RDONLY)) == -1) &#123; oops("Cannot open ", src_str); &#125; if(!access(des_str, F_OK) ) &#123; st_buf = get_stat(des_str); if(S_ISDIR(st_buf.st_mode)) &#123; dir_str = src_str; chdir(des_str); &#125; else &#123; dir_str = des_str; &#125; &#125; else &#123; dir_str = des_str; &#125; if((out_fd = creat(dir_str, FILEMODE)) == -1) &#123; oops("Cannot creat ", des_str); &#125; while((n_chars = read(in_fd, buf, BUFFSZIE)) &gt; 0) &#123; if((write(out_fd, buf, n_chars)) != n_chars) oops("Write error to ", dir_str); &#125; if(n_chars == -1) oops("Read error from ", src_str); if(close(in_fd)== -1 || close(out_fd) == -1) oops("Closing files error ", ""); //返回原目录 chdir(re_buf);&#125;void copy_dir(char *src_str, char *des_str)&#123; DIR *dp; char des_dir_buf[PATHSIZE]; char src_dir_buf[PATHSIZE]; char src_dir_buf_i[PATHSIZE]; struct dirent *dirp; struct stat src_buf; src_buf = get_stat(src_str); if(S_ISDIR(src_buf.st_mode)) &#123; //目录的跳转及记录 getcwd(src_dir_buf, PATHSIZE); chdir(des_str); mkdir(src_str, DIRMODE); chdir(src_str); getcwd(des_dir_buf, PATHSIZE); chdir(src_dir_buf); dp = opendir(src_str); chdir(src_str); getcwd(src_dir_buf_i, PATHSIZE); if(dp == NULL) &#123; perror("opendir"); exit(1); &#125; //循环获取目录信息 while((dirp = readdir(dp)) != NULL) &#123; src_buf = get_stat(dirp-&gt;d_name); if(0 == strcmp(dirp-&gt;d_name, ".") || 0 == strcmp(dirp-&gt;d_name, "..")) continue; else if(S_ISDIR(src_buf.st_mode)) &#123; //进行递归调用 copy_dir(dirp-&gt;d_name, des_dir_buf); &#125; else &#123; //复制文件，进入目的目录 chdir(src_dir_buf_i); copy_file(dirp-&gt;d_name, des_dir_buf); &#125; &#125; closedir(dp); &#125; else &#123; copy_file(src_str, des_str); &#125; //返回之前的目录 chdir(src_dir_buf);&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登陆shell和非登陆shell的区别以及配置文件加载顺序]]></title>
    <url>%2F2018%2F07%2F26%2F%E7%99%BB%E9%99%86shell%E5%92%8C%E9%9D%9E%E7%99%BB%E9%99%86shell%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在Linux根据用户使用shell的情况可以分为登陆shell和非登陆shell，还有交互式shell和非交互式shell。 &emsp;&emsp;登陆shell是指用户使用shell时需要输入用户名和密码登陆，比如从某终端登陆，或者通过su - USERNAME、su -l USERNAME的方式登陆； &emsp;&emsp;非登陆shell则指不需要用户名和密码即可使用shell，比如在图形界面下打开终端窗口，运行的shell脚本，su USERNAME。 &emsp;&emsp;交互式shell就是shell在等待你的输入，键入回车后立马执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、退出，当你退出后，shell自然就终止了，还有一种情况就是执行shell脚本时需要用户进行输入。 &emsp;&emsp;非交互式shell基本就是执行不需要输入任何信息shell脚本，shell和用户之间交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF，shell也就终止了 以bash为例，说一说shell的配置文件 全局配置文件： ​ /etc/profile /etc/profile.d/*.sh /etc/bashrc 用户个人配置文件： ​ ~/.bash_profile ~/.bashrc profile类的文件主要用于： 设定环境变量 、运行命令或脚本 bashrc类的文件则主要同于设定本地变量、定义命令别名 当用户使用登陆shell时，shell会按以下的顺序去加载配置文件： ​ /etc/profile –&gt; /etc/profile.d/*sh –&gt; ~/.bash_profile –&gt; ~/.bashrc –&gt; /etc/bashrc 当用户使用非登陆shell时，shell的配置文件加载顺序变为： ​ ~/.bashrc –&gt; /etc/bashrc –&gt; /etc/profile.d/*.sh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国人失掉自信力了吗? --鲁迅]]></title>
    <url>%2F2018%2F07%2F26%2F%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%A4%B1%E6%8E%89%E8%87%AA%E4%BF%A1%E5%8A%9B%E4%BA%86%E5%90%97%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;从公开的文字上看起来：两年以前，我们总自夸着“地大物博”，是事实；不久就不再自夸了，只希望着国联，也是事实；现在是既不夸自己，也不信国联，改为一味求神拜佛，怀古伤今了——却也是事实。 &emsp;&emsp;于是有人慨叹曰：中国人失掉自信力了 &emsp;&emsp;如果单据这一点现象而论，自信其实是早就失掉了的。先前信“地”，信“物”，后来信“国联”，都没有相信过“自己”。假使这也算一种“信”，那也只能说中国人曾经有过“他信力”，自从对国联失望之后，便把这他信力都失掉了。 &emsp;&emsp;失掉了他信力，就会疑，一个转身，也许能够只相信了自己，倒是一条新生路，但不幸的是逐渐玄虚起来了。信“地”和“物”，还是切实的东西，国联就渺茫，不过这还可以令人不久就省悟到依赖它的不可靠。**一到求神拜佛，可就玄虚之至了，有益或是有害，一时就找不出分明的结果来，它可以令人更长久的麻醉着自己**。 &emsp;&emsp;中国人现在是在发展着“自欺力”。 &emsp;&emsp;“自欺”也并非现在的新东西，现在只不过日见其明显，笼罩了一切罢了。然而，在这笼罩之下，我们有并不失掉自信力的中国人在。 &emsp;&emsp;我们从古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人，……虽是等于为帝王将相作家谱的所谓“正史”，也往往掩不住他们的光耀，这就是中国的脊梁。 &emsp;&emsp;这一类的人们，就是现在也何尝少呢？他们有确信，不自欺；他们在前仆后继的战斗，不过一面总在被摧残，被抹杀，消灭于黑暗中，不能为大家所知道罢了。说中国人失掉了自信力，用以指一部分人则可，倘若加于全体，那简直是诬蔑。 &emsp;&emsp;要论中国人，必须不被搽在表面的自欺欺人的脂粉所诓骗，却看看他的筋骨和脊梁。自信力的有无，状元宰相的文章是不足为据的，要自己去看地底下。 &emsp;&emsp;九月二十五日]]></content>
      <categories>
        <category>文章佳句</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记(2)]]></title>
    <url>%2F2018%2F07%2F24%2FLinux%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;whatis : 用于查询一个命令执行功能，并将查询的结果打印到终端。 &emsp;&emsp;which : 用于查找并显示给命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。 &emsp;&emsp;whreris : 用了定位指令的二进制程序、源代码和man手册页等相关的路径。 &emsp;&emsp;w : 用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。 &emsp;&emsp;who : 用于显示目前登陆系统的用户信息。 &emsp;&emsp;whoami : 打印当前有效用户名称。 引用和转义： &emsp;&emsp;使用反斜线 \ 引用单个字符(转义了这个字符)，比单引号和双引号强 &emsp;&emsp;使用单引号转义一串字符(弱引用) &emsp;&emsp;使用双引号引用一堆字符，但是保留 $ 、\ 、` (反引号) 的特殊含义(强引用) alias可以显示你设置的别名，也可以 alias ll=’ls -l’ ，这样就建立了 ll 为 ls -l 的别名，可以将其写到 shell 的配置文件中 ，比如/etc/bashrc 、~.bashrc，使用 unalias 取消别名，而且我们可以使用 反斜线( \ ) 来屏蔽别名，一般的Linux都会将 ls 设置成 ‘ls -d .* –color=auto’ 的别名，如果使用 \ls 则会屏蔽这个别名。 &emsp;&emsp;Shell常见的状态码，执行一个命令或运行一个程序结束之后，可以使用 echo $? 来查看退出状态码（0—255） 0 命令成功结束 1 通用未知错误 2 误用shell命令 126 命令不可执行 127 没找到命令 128 无效退出参数 128+x Linux信号X的严重错误 130 命令通过Ctrl+C控制码越界 255 退出码越界 查询公网地址： &emsp;&emsp;UNIX/Linux: &emsp;&emsp;&emsp;&emsp;curl cip.cc&emsp;&emsp;&emsp;&emsp;culr ifconfig.me &emsp;&emsp;&emsp;&emsp; curl ip.cn &emsp;&emsp;Windows:&emsp;&emsp;&emsp;&emsp; &emsp;telnet cip.cc&emsp;&emsp;&emsp;&emsp;ftp cip.cc cat -v -e 显示不可打印的字符和行尾 端口号即对应的服务：/etc/service Client端是随机开放一个大于 1024 的 port 进行链接，只有 root 可以启动小于1024的端口 服务端启动的监听端口所对应的服务是固定的，客户端启动程序时，随机启动一个大于 1024 以上的端口 touch可创建文件或者更改文件的3个时间 123atime 最近访问时间mtime 最近更改时间(只修改件内容的时间)ctime 最近改动文件的时间(指最近改动inode的时间,文件属性） shell隐藏密码 1read -p "Please input your passwd:" -s passwd centos安装完整的manpages(支持posix函数（内核api）) 1yum -y install man-pages Ubuntu安装ssr-qt5,实现科学上网 1234sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 sudo apt-get -f install lsat: 显示 /var/log/wtmp 文件，显示用户登录历史和系统重启历史 lastb: 显示 /var/log/btmp 文件，显示用户错误的登录尝试 lastlog: 显示每一个用户最近一次成功登录信息 终端类型： &emsp;&emsp;console: 控制台 &emsp;&emsp;pty: 物理终端 &emsp;&emsp;tty#: 虚拟终端 &emsp;&emsp;ttyS#: 串行终端 &emsp;&emsp;pts#: 伪终端 Linux的6种运行级别： &emsp;&emsp;0: halt，关机 &emsp;&emsp;1: single user mode，无需密码，直接以管理员身份登录 &emsp;&emsp;2: multi user mode, no NFS, 不带网络的多用户模式 &emsp;&emsp;3: multi user mode, text mode, 多用户模式，文本界面 &emsp;&emsp;4: reserved 保留 &emsp;&emsp;5: multi user mode, graphic mode 带图形界面的多用户模式 &emsp;&emsp;6: reboot 重启 一般的 Linux 启动流程： &emsp;&emsp;POST –&gt; BIOS(Boot Sequence) –&gt; MBR(bootloader) –&gt; kernel –&gt; initrd –&gt; (ROOTFS) /sbin/init (/etc/inittab)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记(1)]]></title>
    <url>%2F2018%2F07%2F24%2FLinux%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Man page 为Manual page,是linux /unix 环境下命令与函数的帮助文档 ，共9个章节 &emsp;&emsp;1. 用户在shell环境中可以操作的命令或可执行文件。 &emsp;&emsp;2. 系统内核API函数与工具。 &emsp;&emsp;3. 一些常见的函数与函数库，大部分为C语言的函数库。 &emsp;&emsp;4. 设备文件的说明，设备文件通常在/dev目录下。 &emsp;&emsp;5. 配置文件或某些文件的格式。 &emsp;&emsp;6. 游戏（GAME）； &emsp;&emsp;7. 惯例与协议等，例如Linux文件系统、网络协议、ASCII code等等的说明 . &emsp;&emsp;8. 系统管理员可用的管理命令 . &emsp;&emsp;9. 与kernel有关的文件。 &emsp;&emsp;大多数Linux发行版都采用FHS(Filesystem Hierarchy Standard 文件系统层次化标准) ，简单介绍一下Linux常见目录 /bin 存放系统管理维护的常用命令文件 /boot 存放用于系统启动的内核文件和引导装载程序文件 /dev 存放设备文件 /etc 存放配置文件 /home 各用户的主目录，其中的子目录即为各用户名 /lib 存放动态链接共享库 /media 光盘软盘默认挂载点 /mnt 为某些设备提供挂载点 /root root用户家目录 /sys 伪文件系统，和硬件设备相关的属性映射文件 /proc 伪文件系统，系统自动产生的映射 /sbin 存放系统管理员或root用户使用的命令文件 /usr 存放应用程序和文件 /var 保存经常变化的内容，如系统日志 /opt 可选目录，第三方程序安装目录，如ubuntu上dpkg安装deb包，程序放在此目录 /srv service，网路服务启动之后所需要取用的资料目录 /lost+found 记录硬盘上的partition资料流失时作fsck寻找回来的遗失文件片段 /tmp 临时文件 &emsp;&emsp;常见的快捷键 CTRL + L 清屏，等同于clear CTRL + A 移动到命令行开始 CTRL + E 移动到命令行结尾 CTRL + K 清除光标到命令行结尾的内容 CTRL + U 清除光标到命令行开始的内容 CTRL + R 查找历史命令（输入关键字，搜索以前出现过的命令） CTRL + C 中断一个进程 CTRL + D 输入结束(EOF),空命令行下退出终端，即EXIT CTRL + Z 将进程挂起到后台（使用fg恢复到前台） CTRL + \ 退出进程 ESC + . 上一个命令的参数 &emsp;&emsp;下面介绍一下信号，我们以 ^ 来表示 CTRL键： &emsp;&emsp;^W相当于发送werase，删除最后一个键入的单词 &emsp;&emsp;erase 删除最后一个键入的字符 Ctrl+H(^H) &emsp;&emsp;kill 删除整行 Ctrl + U(^U) &emsp;&emsp;intr 信号 ^C 取消命令，停止一个僵死程序 &emsp;&emsp;信号quit 退出：^ \ (Ctrl + \ ) &emsp;&emsp;信号stop：停止输出的显示，不会暂停正在执行的任务：^ s &emsp;&emsp;文件结束信号EOF：^D &emsp;&emsp;封闭EOF信号：IGNOREEOF &emsp;&emsp;显示键盘映射：stty -a &emsp;&emsp;挂起信号：susp: ^Z (SUSPENDED ) &emsp;&emsp;返回信号：^M \r &emsp;&emsp;换行信号：^J \n &emsp;&emsp;在文本文件中，Unix使用 ^J (newline) 字符标记每行结束，Windows使用 ^M ^J 标记每行的结束。 最后记录一个关于ifconfig问题：在最小化安装Linux发行版或者装像Debian、Kali的时候，使用 ifconfig 查看 IP，会发现 ifconfig 命令不存在，此时我们就需要安装 net-tools，缺少 netstat 命令时也需要安装net-tools，而且ifconfig是net-tools中已被废弃使用的一个命令，非常老旧，我们可以使用iproute2套件里提供 ip 命令来代替它， ip addr 即可查看IP地址。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rm命令的简单实现]]></title>
    <url>%2F2018%2F07%2F23%2Frm%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;毫无疑问，rm命令是Unix类系统上不可缺少的命令之一，文件目录删除全靠它，此篇实现rm的功能。 &emsp;&emsp;通常我们在使用rm命令时只能删除文件并不能删除目录，若要删除目录，我们加参数 -f 进行强制删除，常用的还有 -r 递归删除，-rf 是Unix类系统命令行参数最经典的搭配之一。 &emsp;&emsp;首先删除文件很简单，直接将此文件 unlink 即可，删除空目录就使用 rmdir() 函数，我们使用 lstat() 函数将命令行参数的信息保存到结构体 struct argv_buf 中，根据函数 S_ISDIR() 来传入的参数是目录还是其他文件；此时问题来了，文件或目录不存在怎么办，目录不为空怎么办，有多重目录怎么办。 &emsp;&emsp;第一个问题很好解决，在删除之前我们先调用函数 access() 判断文件或目录是否存在，若不存在直接退出，并打印perror错误信息； &emsp;&emsp;第二和第三个问题可以一起解决，此时我们就是需要使用 opendir() 函数打开该目录，随后使用 chdir() 进入该目录，再使用 readdir() 函数配合 while 循环读取该目录内包含的所有信息，判断文件为目录文件还是非目录文件，非目录文件直接 unlink 删除，目录文件的进行递归调用进入该目录，重复上述操作，注意：我们应该过滤掉当前目录 . 和其父目录 .. ，而且删除当前目录所有文件后我们必须调用 chdir() 函数返回上级目录。 &emsp;&emsp;最后补充一下Unix类系统删除文件的内核操作：当rm删除文件时，只是删除目录下的记录项和吧inode硬链接技术减一，当硬链接技术减为0时才会真正删除文件，同样close函数关闭一个文件没描述符时，只是对其计数减一，为0时才真正关闭。而且删除文件并不是真正的删除，只是解除了inode指向data的链接，并没有抹除数据，若没有进行写操作，可以对文件进行恢复。 &emsp;&emsp;附上源码：myrm.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/fcntl.h&gt;#include &lt;sys/stat.h&gt;//获取文件类型，主要是目录和其他文件,目录返回1，其他文件返回0int get_type(int mode)&#123; if(S_ISDIR(mode)) return 1; else return 0;&#125;//获取文件的状态,返回文件的st_modeint get_mode(const char *pathname)&#123; struct stat argv_buf; if(lstat(pathname, &amp;argv_buf) &lt; 0) &#123; perror("lstat"); exit(1); &#125; return argv_buf.st_mode;&#125;//删除文件void rm_file(const char *pathname)&#123; unlink(pathname);&#125;//删除目录void rm_dir(const char *pathname)&#123; rmdir(pathname);&#125;//递归删除目录及文件void rm_dir_re(const char *pathname)&#123; DIR *dp; struct dirent *dirp; struct stat dir_buf; int dir_flag; dp = opendir(pathname); chdir(pathname); if(dp == NULL) &#123; perror("opendir"); exit(1); &#125; while((dirp = readdir(dp)) != NULL) &#123; dir_flag = lstat(dirp-&gt;d_name, &amp;dir_buf) ; if(dir_flag &lt; 0) &#123; perror("lstat"); exit(1); &#125; if(S_ISDIR(dir_buf.st_mode)) &#123; if(0 == strcmp(dirp-&gt;d_name, ".") || 0 == strcmp(dirp-&gt;d_name, "..")) continue; else rm_dir_re(dirp-&gt;d_name); &#125; if(0 == get_type(dir_buf.st_mode)) &#123; unlink(dirp-&gt;d_name); &#125; &#125; closedir(dp); chdir(".."); rm_dir(pathname);&#125;//判断文件是否存在void is_exist(const char *pathname)&#123; if(access(pathname, F_OK) &lt; 0) &#123; printf("%s is not exist\n", pathname); exit(1); &#125;&#125;int main(int argc, char *argv[])&#123; int i; if(1 == argc) &#123; printf("Usage:./myrm filename OR ./myrm -rf diretory\n"); exit(1); &#125; if(2 == argc) &#123; is_exist(argv[1]); if(get_type(get_mode(argv[1]))) &#123; printf("myrm: cannot remove ‘%s’: Is a directory\n", argv[1]); &#125; rm_file(argv[1]); &#125; if(3 == argc) &#123; if(strcmp(argv[1], "-rf") != 0) &#123; is_exist(argv[1]); if(get_type(get_mode(argv[1]))) &#123; printf("myrm: cannot remove ‘%s’: Is a directory\n", argv[1]); &#125; rm_file(argv[1]); is_exist(argv[2]); if(get_type(get_mode(argv[2]))) &#123; printf("myrm: cannot remove ‘%s’: Is a directory\n", argv[2]); &#125; rm_file(argv[2]); exit(1); &#125; is_exist(argv[2]); if(get_type(get_mode(argv[2]))) &#123; rm_dir_re(argv[2]); &#125; else &#123; rm_file(argv[2]); &#125; &#125; if(argc &gt; 3) &#123; if(strcmp(argv[1], "-rf") == 0) &#123; for(i = 2; i &lt; argc; i++) &#123; is_exist(argv[i]); if(get_type(get_mode(argv[i]))) &#123; rm_dir_re(argv[i]); &#125; else &#123; rm_file(argv[i]); &#125; &#125; &#125; else &#123; for(i = 1; i &lt; argc; i++) &#123; is_exist(argv[i]); if(get_type(get_mode(argv[i]))) &#123; printf("myrm: cannot remove ‘%s’: Is a directory\n", argv[i]); &#125; rm_file(argv[i]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP的有限状态机]]></title>
    <url>%2F2018%2F07%2F19%2FTCP-IP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;TCP/IP的有限状态机是指客户端和服务器建立起一个TCP连接到断开连接的11种状态之间的转换，包括建立连接的三次握手和断开连接的四次挥手过程。 &emsp;&emsp;TCP状态表 状态 描述 CLOSED 关闭状态，没有连接活动或正在进行 LISTEN 监听状态，服务器正在等待客户端的TCP请求 SYN_SENT 已经发出连接请求，等待确认 ， TCP第一次握手后客户端所处的状态 SYN_RCVD 收到一个连接请求，尚未确认 , TCP第二次握手后服务端所处的状态 ESTABLISHED 连接建立，正常数据传输状态 ，TCP第三次握手后双方的状态 FIN_WAIT_1 （主动关闭）已经发送关闭请求，等待确认 FIN_WAIT_2 （主动关闭）收到对方关闭确认，等待对方关闭请求 CLOSE_WAIT （被动关闭）收到对方关闭请求，已经确认 CLOSING 双方同时尝试关闭，等待对方确认 LAST_ACK （被动关闭）等待最后一个关闭确认，并等待所有分组关闭 TIMED_WAIT 完成双向关闭，等待所有分组断开，等待时间一般为（2MSL） &emsp;&emsp;当一个TCP连接建立的时候，第一个过程就是三次握手 &emsp;&emsp;1.服务端处于LISTEN监听状态，称为被动打开 &emsp;&emsp;2.客户端主动向服务端发起连接请求即客户端发送SYN包（syn=j）到服务器，并且进入SYN_SENT 状态，等待服务器的确认。 &emsp;&emsp;3.服务器端收到来自客户端的SYN包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k）及SYN+ACk包，服务器进入SYN_RCVD 。 &emsp;&emsp;4.客户端收到服务器发送的SYN+ACK包，并向服务器发送确认包ACK（ack=k+），服务器接收后双方进入ESTABLISHED状态，完成三次握手。 此后可以开始传输数据。 &emsp;&emsp;当一个TCP连接数据传输完毕，需要断开连接的时候就会进入四次挥手阶段，主要是客户端发起断开连接请求 &emsp;&emsp;1.客户端向服务端发送关闭请求FIN包（fin=m），发送后客户端处于FIN_WAIT_1状态，第一次挥手 &emsp;&emsp;2.服务端接受数据包后变为CLOSE_WAIT状态，并向客户端发送确认包ACK（m+1），第二次挥手。 &emsp;&emsp;3.客户端收到来自服务端发送的ACK包后进入FIN_WAIT_2状态，等待服务端发送关闭请求。 &emsp;&emsp;4.服务端向客户端发起关闭请求FIN包（fin=n），并进入LAST_ACK状态，第三次挥手。 &emsp;&emsp;5.客户端收到请求后发送确认请求包ACK（ack=n+1)，然后进入TIME_WAIT状态，第四次挥手。 &emsp;&emsp;6.服务端收到客户端的确认包后变为CLOSED状态，然后又变为LISTEN状态继续监听。 &emsp;&emsp;7.客户端在TIME_WAIT状态等待2MSL时间后变为CLOSED，整个连接关闭。 &emsp;&emsp;TCP状态装换图]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP四层模型及OSI七层模型]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%AF%B9%E4%BA%8ETCP-IP%E4%B8%83%E5%B1%82%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;OSI七层模型自底向上分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 &emsp;&emsp;现在基本简化为TCP/IP四层模型：数据链路层（bit）、网络层（数据帧）、传输层（数据包）、应用层（数据段） &emsp;&emsp;很明显的可以看到四层模型简化了七层模型，其对应关系如下： OSI七层模型TCP/IP四层模型网络协议应用层（Application应用层 HTTP、TFTP, FTP, NFS, WAIS、SMTP表示层（Presentation）Telnet, Rlogin, SNMP, Gopher会话层（Session）SMTP, DNS传输层（Transport）传输层TCP, UDP网络层（Network）网络层IP, ICMP, ARP, RARP, AKP, UUCP数据链路层（Data Link）数据链路层FDDI, Ethernet, Arpanet, PDN, SLIP, PPP物理层（Physical）IEEE 802.1A, IEEE 802.2到IEEE 802.11 &emsp;&emsp;每一层对于上一层来讲是透明的，上层只需要使用下层提供的接口，并不关心下层是如何实现的 &emsp;&emsp;OSI七层协议模型(Open System Interconnect 开放系统互连参考模型) 1.物理层：利用传输介质(电缆、双绞线等)为数据链路层提供物理连接，实现比特流(位流)的透明传输。尽可能屏蔽掉具体传输介质与物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。 2.数据链路层 ：受来自物理层的位流形式的数据，并封装成帧，传送到上一层 ；同样，也将来自上一层的数据帧，拆装为位流形式的数据转发到物理层；并且还负责处理接受端发回的确认帧的信息，以便提供可靠的数据传输。 3.网络层： 数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。 数据链路层是解决统一网络内节点之间的通信，而网络层主要解决不同子网之间的通信。 4.传输层： 向用户提供可靠的、端到端的差错和流量控制，保证报文的正确传输。向高层屏蔽下层数据通信的具体细节，即向用户透明的传送报文。 提供了面向链接的TCP和面向无连接的UDP传输服务。 5.会话层： 向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。 用户可以按照半双工、单工和全工的方式建立会话。 6.表示层： 对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。 处理用户信息的表示问题，如编码、数据格式转换和加密解密等。 7.应用层： 它是计算机用户，以及各种应用程序和网络之间的接口。直接向用户提供服务，完成用户在网络上的期望工作。 在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。 &emsp;&emsp;1.物理层： TCP/IP四层模型 1.数据链路层： 包括操作系统中的设备驱动程序、计算机中对应的网络接口卡 。 2.网络层： TCP/IP互联网层协议处理跨越多个网络的机器之间的路由问题，它也管理网络名称和地址，以利于解决路由问题。 实现物理地址到网络地址的转换。 3.传输层： 主要为两台主机上的应用提供端到端的通信（ TCP、UDP）。 &emsp;&emsp;TCP与UDP的区别 &emsp;&emsp;1.基于连接(TCP)和无链接(UDP) &emsp;&emsp;2.对系统资源的要求（TCP较多，UDP较少） &emsp;&emsp;3.UDP程序结构比较简单，TCP比较复杂 &emsp;&emsp;4.流模式与数据模式 &emsp;&emsp;5.TCP保证数据的正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证 4.应用层： 为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等 网络层与传输层的区别： 在TCP/TP协议族中， 网络层IP提供的是一种不可靠的服务。它只是尽可能快地把分组从源节点送到目的节点，但不提供任何可靠性的保证。 TCP在不可靠的IP层上，提供了一个可靠的运输层，为了提供这种可靠的服务，TCP采用了超时重传、发送和接受端到端的确认分组等机制。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ls命令的简单实现]]></title>
    <url>%2F2018%2F07%2F17%2Fls%E5%91%BD%E4%BB%A4%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;ls命令可以说是Unix类系统上参数选项最多的命令之一，此篇实现ls -l的简单功能。 &emsp;&emsp;ls -l 显示一个文件很容易实现，但如果需要 ls -l 一个目录的所有文件就组要费一点脑筋；本篇实现的是 ls 查看一个目录的所有文件的详细信息，至于显示单个文件只需改动一番即可。 &emsp;&emsp;具体的思路是先 chdir() 到指定的目录，然后打开此目录，使用一个DIR 类型的指针 (DIR *) 来获取知道目录的信息，再用while循环配合 readdir() 函数来依次读取目录内的文件，返回一个struct dirent结构体；从该结构体中获取文件的路径名并以此作为 lstat()函数的参数，将文件的信息保存到 struct stat 类型的结构中，从该结构体中提取所需要的信息即可。 &emsp;&emsp;从 struct stat 结构体中获取文件的信息并输出只是一些简单的判断、逻辑操作，具体看代码，至于颜色可以通过不同的文件类型配合 printf() 函数输出。 &emsp;&emsp;附上源码myls.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/fcntl.h&gt;#include &lt;dirent.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;pwd.h&gt;#include &lt;grp.h&gt;//由uid转换为用户名char *uid_to_name(uid_t uid)&#123; struct passwd *passwd; passwd = getpwuid(uid); return passwd-&gt;pw_name;&#125;//由gid转换为用户组名char *gid_to_name(gid_t gid)&#123; struct group *group; group = getgrgid(gid); return group-&gt;gr_name;&#125;//获取文件类型及权限void get_type(int mode, char *str)&#123; strcpy(str, "----------"); //获取文件类型 if(S_ISDIR(mode)) str[0] = 'd'; if(S_ISCHR(mode)) str[0] = 'c'; if(S_ISBLK(mode)) str[0] = 'b'; if(S_ISFIFO(mode)) str[0] = 'p'; if(S_ISLNK(mode)) str[0] = 'l'; if(S_ISSOCK(mode)) str[0] = 's'; //获取文件权限 if(mode &amp; S_IRUSR) str[1] = 'r'; if(mode &amp; S_IWUSR) str[2] = 'w'; if(mode &amp; S_ISUID) str[3] = 's'; else if(mode &amp; S_IXUSR) str[3] = 'x'; if(mode &amp; S_IRGRP) str[4] = 'r'; if(mode &amp; S_IWGRP) str[5] = 'w'; if(mode &amp; S_ISGID) str[6] = 's'; else if(mode &amp; S_IXGRP) str[6] = 'x'; if(mode &amp; S_IROTH) str[7] = 'r'; if(mode &amp; S_IWOTH) str[8] = 'w'; if(mode &amp; S_ISVTX) str[9] = 't'; else if(mode &amp; S_IXOTH) str[9] = 'x';&#125;//获取一个目录的所有文件信息void get_files( const char *str)&#123; DIR *dp; struct dirent *dirp; struct stat stat_buf; int flag; char str_mode[11]; chdir(str); dp = opendir(str); if(dp == NULL) &#123; perror("open"); exit(1); &#125; while((dirp = readdir(dp)) != NULL) &#123; flag = lstat(dirp-&gt;d_name, &amp;stat_buf); if(flag &lt; 0) &#123; perror("lstat"); exit(1); &#125; //除去.和.. if(S_ISDIR(stat_buf.st_mode)) &#123; if(strcmp(dirp-&gt;d_name, ".") == 0 || strcmp(dirp-&gt;d_name, "..") == 0) continue; &#125; get_type(stat_buf.st_mode, str_mode); printf("%s", str_mode); printf("%4d ",(int)stat_buf.st_nlink); printf("%-8s%-8s", uid_to_name(stat_buf.st_uid), gid_to_name(stat_buf.st_gid)); printf("%8ld ", stat_buf.st_size); printf("%.12s ", ctime(&amp;stat_buf.st_mtim)); printf("%s\n", dirp-&gt;d_name); &#125; closedir(dp);&#125;int main(int argc, char *argv[])&#123; //实现ls . if(argc == 1) &#123; get_files("."); &#125; //实现ls -l if(argc == 2) &#123; get_files(argv[1]); &#125; if(argc &gt; 2) &#123; printf("Usage:./myls -l\n"); exit(1); &#125; return 0;&#125; 效果图如下：]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现快速排序]]></title>
    <url>%2F2018%2F07%2F16%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;快速排序又称划分交换排序，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n) 次比较。在最坏状况下则需要O(n²)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他算法更快，因为它的内部循环可以在大部分的架构上很有效率的实现出来。 &emsp;&emsp;快排的基本思想是通过一趟将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此让整个数列变成有序序列。 &emsp;&emsp; 快速排序是找出一个元素（理论上可以随便找一个）作为基准(pivot),然后对数组进行分区操作,使基准左边元素的值都不大于基准值,基准右边的元素值 都不小于基准值，如此作为基准的元素调整到排序后的正确位置。递归快速排序，将其他n-1个元素也调整到排序后的正确位置。最后每个元素都是在排序后的正 确位置，排序完成。所以快速排序算法的核心算法是分区操作，即如何调整基准的位置以及调整返回基准的最终位置以便分治递归。 &emsp;&emsp; 举一个例子： &emsp;&emsp; 2 2 4 9 3 6 7 1 5 首先用2当作基准，使用i j两个指针分别从两边进行扫描，把比2小的元素和比2大的元素分开。首先比较2和5，5比2大，j左移 &emsp;&emsp;2 2 4 9 3 6 7 1 5 比较2和1，1小于2，所以把1放在2的位置 &emsp;&emsp;2 1 4 9 3 6 7 1 5 比较2和4，4大于2，因此将4移动到后面 &emsp;&emsp;2 1 4 9 3 6 7 4 5 比较2和7，2和6，2和3，2和9，全部大于2，满足条件，因此不变 &emsp;&emsp;经过第一轮的快速排序，元素变为下面的样子: &emsp;&emsp; [1] 2 [4 9 3 6 7 5] &emsp;&emsp;之后，在把2左边的元素进行快排，由于只有一个元素，因此快排结束。右边进行快排，递归进行，最终生成最后的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;time.h&gt;//交换两个数void t_swap(int *m, int *n)&#123; int temp; temp = *n; *n = *m; *m = temp; return ;&#125;//打印数组void display_array(int array[], int len)&#123; int i; for(i = 0; i &lt; len; i++) &#123; printf("%d\t", array[i]); &#125; printf("\n"); return ;&#125;//以随机数的方式生成数组，不能生成负数void b_array(int array[], int len, int m)&#123; //时间种子 srand((int)time(0)); int i; for(i = 0; i &lt; len; i++) &#123; //随机数rand()对m取余，生成0~m间的随机数，并赋值给数组元素 array[i] = (int)(rand() % m); &#125; return ;&#125;//快排函数void quicksort(int array[], int len, int left, int right)&#123; int i, j; if(left &lt; right) &#123; // 将array[left]作为基准数，从array[left+1]开始与基准数比较,i为左标记 i = left + 1; // array[right]是数组的最后一位，j为有标记 j = right; while(i &lt; j) &#123; // 如果比较的数组元素大于基准数，则交换位置 if(array[i] &gt; array[left]) &#123; // 交换两个数 t_swap(&amp;array[i], &amp;array[j]); // 右标记左移一位 j--; &#125; else &#123; // 左标记右移一位，继续与基准数比较 i++; &#125; &#125; /* 跳出while循环后，i = j * 此时数组被分割成两个部分 --&gt; array[left+1] ~ array[i-1] &lt; array[left] * --&gt; array[i+1] ~ array[right] &gt; array[left] * 此时将数组array分成两个部分，把array[i]与array[left]进行比较，决定array[i]的位置 * 最后将array[i]与array[left]交换，进行两个分割部分的排序！以此类推，直到最后i = j不满足条件就退出 */ // 此处必须取等“&gt;=”，否则数组元素值相同时，会出现错误 if(array[i] &gt;= array[left]) &#123; i--; &#125; // 交换array[i]与array[begin] t_swap(&amp;array[i], &amp;array[left]); //两边分别递归调用快排函数，递归结束的标志是left&gt;=right quicksort(array, len, left, i); quicksort(array, len, j, right); &#125; return ;&#125;int main()&#123; int n, m; printf("请输入数组的长度："); scanf("%d", &amp;n); printf("请输入你期望数组元素的最大值："); scanf("%d", &amp;m); int array[n]; b_array(array, n, m); printf("排序前的数组：\n"); display_array(array, n); quicksort(array, n, 0, n - 1); printf("排序后的数组：\n"); display_array(array, n); return 0;&#125; &emsp;&emsp;分析： &emsp;&emsp; 快速排序的时间主要耗费在划分操作上，对长度为k的区间进行划分，共需k-1次关键字的比较。 &emsp;&emsp;最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)，而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。时间复杂度为O(n*n) &emsp;&emsp; 在最好情况下，每次划分所取的基准都是当前无序区的”中值”记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。总的关键字比较次数：O(nlgn) &emsp;&emsp;尽管快速排序的最坏时间为O(n2)，但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。它的平均时间复杂度为O(nlgn)]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linuxer怎么直面内心的挣扎？]]></title>
    <url>%2F2018%2F07%2F16%2FLinuxer%E6%80%8E%E4%B9%88%E7%9B%B4%E9%9D%A2%E5%86%85%E5%BF%83%E7%9A%84%E6%8C%A3%E6%89%8E%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;为什么今天要写出来？&emsp;&emsp;为什么是今天要写这样一篇文章？这篇文章是我混迹linux世界这么久一直想说的很多话的集合，从年初就一直想写一篇这样的文章，苦于当时脑袋里面都是只言片语，并不成系统，再加上我一直面对开源社区很多看不惯的做法一贯都是怼回去的做法，比如在知乎上和各路妖魔鬼怪狂撕，事实证明互撕会导致自己智商和情商降低，远不如一篇系统的文章更具说服力，就像我用超长文《深度桌面操作系统架构设计》放到知乎上以后，无谓的口水都要少好多。 &emsp;&emsp;所以这大半年写文章和代码时一直在构思怎么理性而又饱含深情的 “胡说八道”， 直到今天在看《火星崛起3》的时候，看到戴罗在自己最脆弱的时候面临最强大的敌人时，对自己最信任的战友说的话： &emsp;&emsp;… 问题就出在这里：我一样不知道怎么打赢这场战争，也不会假装自己有答案。可是我也不会就这么应了高古斯都的预言，什么计划都没有，直接带领人类走向混沌。正因如此，我们需要贾王这样的盟友，而且不能走恐怖分子路线，必须召集真正的军队 … &emsp;&emsp;这段话之前，戴罗和他最亲密的战友打得不可开交…随着最激烈的战斗画面脑补到戴罗的突然降温的这段话，突然这篇文章之前零零碎碎的构思突然就理顺了。 &emsp;&emsp;更加明白了，怎么用一种反常的理性来阐述我内心的愤怒，更能让你们这帮技术高深的 ”高智商混蛋“ 能够不带着抵触情绪耐心的看完另外一整篇长文，哈哈哈。 &emsp;&emsp;这么多LINUXER挣扎的来源？&emsp;&emsp; 每一个Linuxer都是折翼的天使，都是一个智商超级高的善良人，至少最开始学习Linux的时候是这样的 &emsp;&emsp;我玩Linux十几年了，代码也写了很多，虽然还没有那么多开源的前辈的代码多胡子长，至少也算什么神鬼蛇神都见过的，从内心一直在想一个问题，在现代互联网和通信异常发达的时代，大家都学的都是几乎一样的Linux知识，为什么国外的开源发展的如火如荼，而且大多数Linuxer乐在其中，而国内的Linuxer大多数都比较艰苦，在面对互联网块钱快餐理论的狂轰乱炸下，发展的越来越…怎么说呢？没有希望 &emsp;&emsp;就像昨天有一位朋友关心的问 ”深度最近怎么样？”，我完全知道朋友在想什么，长时间的沟通和了解情况下，询问中透露出一丝丝常规式的关心，我想了半天，最后打了一句 ”哈哈哈，还活着 “, 我想这句饱含深情的话最具幽默感，果不其然，朋友发了两个”哈哈“过来。我想这种感觉不光是deepiner有这种感觉，很多中国做开源的单兵英雄和小而美的团体都生活在这种氛围中，在众人皆快我独怪的大氛围中艰难的努力和坚持。 &emsp;&emsp;从经济发展和物理规律来看，本质上的原因是，开源运动这种纯粹精神领域的折腾是要建立在足够的物质条件上的，人总是遵循：“长时间教育学习→在社会上活下去→活得好过上理想生活→钱赚的多了生活无聊了找点乐子” 的规律去折腾这一生的。一个人和一个社会只有经济发达到一定程度，让人完全忘记 “活下去” 的本能威胁后，人才会毫无危机感的去 “玩” 开源。 &emsp;&emsp;在物理规律之下，当下的中国开源的主要矛盾是： &emsp;&emsp;一个长不大的大男孩好奇探索世界初心和一个有嗷嗷待哺小朋友后被迫当父亲的强烈责任心之间的相互矛盾 &emsp;&emsp;这种强烈的、不用负责任的、主动探索的好奇心遇到那种同样强烈的、每天都要想家人生存的、被动的做不喜欢事情的现实冲击，造就了一大批 “具有社会主义特色中国IT宅男” 的自然景观。&emsp;&emsp;我相信大多数Linuxer在第一次读《地下》、《大教堂与集市》、《黑客与画家》、GNU历史、Linux开源运动的时候，都会被世界上最顶尖黑客键盘敲击声背后那种纯粹的、发自内心的、绝对公正和自由的伟大远见以及无畏的英雄气质所深深震撼，看着千万行的超大软件工程就像集市一般不可思议的构建起来后，自己也多么希望参与到这场全人类的伟大事业中，就算自己最后成为不了大师，做开源和自由软件本身也能在养家糊口前提下, 不违背自己最坚守和最看重的良心。 &emsp;&emsp;我相信大多数Linuxer都是从当初最真实的震撼和坚守到今天的不论好与坏… &emsp;&emsp;我个人来看，今天中国大多数Linuxer挣扎的本质在于： &emsp;&emsp;内心的理想世界和个人能力无法改变世界带来自我受挫的矛盾 &emsp;&emsp;怎么从挣扎变成高智商混蛋？&emsp;&emsp;如果一个社会和一代人主要的矛盾不解决，就会上升成为一种社会问题，至今仍然相信和坚守开源的你们应该也可以看到，中国开源社区并没有衍生出足够多的回归内心和开源本源的开源中坚力量，而是在整个社会的浮躁、鼓励享乐鄙视基础科学研究、一套套互联网的赚钱论把一代人的无穷欲望深深的撩起来了，你内心越喜欢看黑暗，互联网快餐就以最快的方式造黑暗供你“享受”。 &emsp;&emsp;中国的开源不是像黑客马拉松那样大家想象的越来越多了，而是越来越功利心了，催生出一大帮为了赚钱和吸引眼球的技术人放弃专研，天天把简单的道理吹得天昏地暗，一大帮郁郁不得志的人，从开源爱好者变成 “高智商混蛋”，不做贡献，只会天天吹牛，开键盘会，断章取义的评论所有来抬高自己，却总是把自己从自己的理论中排除在外。&emsp;&emsp;就像文章最开始说的那样，我不想纠结混蛋如何如何，我只想像柴静的《苍穹之下》那样，分析背后的现象和原因，看看能否从原因走到一些深入思考的地方，给大家的脑袋里面塞一些不同的声音，如果能够带动一部分实干家加入开源运动，也算是不枉写那么多代码和文章，没白活… &emsp;&emsp;从现状看，中国开源社区中人的分布呈金字塔型： &emsp;&emsp;最底部的是大多数学习不努力的人，不论做开源还是其他，都拿着自己的不努力和逻辑不通当成最伟大的借口，伸手要一切自己想要的东西，如果有一天不如意了，就只会在网上用键盘自导自演的提出虚拟的场景和YY世界来证明自己是对的，而别人都是错的&emsp;&emsp;接着是一部分心理受伤害者，不论是小时候的不如意还是社交上的障碍，选择开源更像开源对自我封闭和自我孤独的一种心理寄托，自己通过后天的努力学到了一部分技术，能够养活自己，同时希望通过技术辩论来构建一圈保护自己的领地，喜欢在技术上和别人争论的天昏地暗，浪费了大部分时间都在争论上，与其说是爱好争论，还不如说是为了用技术保护自己的一种防御手段，如果这种防御手段再加上 “你不用自由软件你就是垃圾” 的宗教式的强迫症，就更令人讨厌了&emsp;&emsp;极少数人，异常专注的努力后，既养活了自己和家人，又获得财务自由，在中国这种儒家思想、权威不容挑战的社会氛围下，大多数人选择了另外一种与世无争的生活，往往随着物质生活达到一定程度后，在开源世界销声匿迹，甚至不再做开源事业，用一种更回归自然的方式的宣扬自己最初对开源精神的理解&emsp;&emsp;世界级少数的天才，我认为开源社区的领袖力量的有两种类型的发展方向，一种就是开源大牛型的，创建了世界伟大的开源项目，99%的时间都花在写代码上了，认为代码是诠释自己思想最好的形式，很少把自己除代码以外的思想公开讨论，更不用说和外界讨论了。另一种就像RMS一样，技术上和思想上都极赋远见，但是因为他个人太耀眼，观点很难被接受，这样从技术上和思想上都能够影响世界的人慢慢的都快绝种了&emsp;&emsp;从开源社区的人群分布来看，真正有实力能够影响开源社区的人要不是归隐桃源、要不就是专注代码，真正技术和思想上都有独立思考不人云亦云的领袖型人物几乎不存在，而在开源社区中发声的更多是，教条式的理解自由软件用技术压迫别人和自己不努力键盘党传递负能量的人居多。而相对于技术用户而言，要多上万倍的非技术人群要不就是被气走了，要不就是看笑话或者看不懂走了，非技术人群参与开源运动极少。 &emsp;&emsp;不得不说，中国开源社区现状一句话就是： &emsp;&emsp;装逼吹牛的人居多、真正的产品用户很少、能够给开源社区带来推动的实干者极度稀少 &emsp;&emsp;非技术人群是推广开源运动不可或缺的力量，甚至是主力，可却因为上面的情况导致，开源运动演变成技术用户自私的守护自己个人爱好的领地，甚至故意排挤非技术用户加入到开源社区。 &emsp;&emsp;我在DEEPIN的每一天都在思考 “战争”&emsp;&emsp;我在deepin工作的7年多，我大部分时间都在战斗中，有时候也会很颓废，颓废的时候就自我开玩笑问我自己我在干什么？我自己回答： &emsp;&emsp;”我在思考怎么打赢一场实力悬殊的战争“ &emsp;&emsp;在知道打赢之前，我看到的战争对局往往让我都感到绝望： &emsp;&emsp;微软和苹果更懂普通大众在想什么，而开源社区连合格的产品经理都鲜有，更不用说站在用户同理心去理解用户的痛和花时间做真正的产品&emsp;&emsp;微软和苹果造了成百上千的应用航母舰队，形成全方位的立体战斗力为它们自己的技术和商业护航，而开源社区却教条的用KISS原则针对某个开发者造了一艘初级的应用木船，都要用狭隘的、自私的技术人自身利益角度去口诛笔伐&emsp;&emsp;微软和苹果知道利益分享才是生态发展的帝国基石，而开源社区大多数开发者在不理解商业本质的情况下，却还在为哪个技术更精巧而你争我斗&emsp;&emsp;微软和苹果知道上千人团队开发的力量，而开源社区却只相信英雄单兵作战，可惜英雄也会老，英雄精神却后继无人&emsp;&emsp;最可怕的是，巨人在苏醒，用开源的模式来剿灭曾经它们看不上的一星半点’开源反抗军‘&emsp;&emsp;如果把开源运动和传统软件的闭源现状当成一种战争革命的话，现在的开源社区状态最多就是游击队，在某些零散的领域造成了星点袭扰，面对基础设施、物质后勤、领导统御、生态联盟更加成熟和健全的微软帝国，开源真的造成了动摇和威胁了吗？ &emsp;&emsp;就连这几年被开源社区当做无脑宣传的安卓真的达到大家YY的理想国了吗？不论从技术还是生态发展上都达到了吗？一点都不： &emsp;&emsp;技术上，从开源技术人YY的Linux构建的手机操作系统到安卓内核从Linux主分支中彻底剥离和抛弃，安卓真的从技术上大量回馈了Linux了吗？反而从商业成功到内核代码自成一体系&emsp;&emsp;从生态发展上，安卓真的带动了商业程序的开源运动了吗？撇开那些从所谓平台而不得不开源的各种框架外，这个世界上又有多少企业真正认同开源文化，而从道德自律上去支持开源运动呢？有多少呢？你几双手可以数完？&emsp;&emsp;开源社区和开源运动在传统帝国和互联网商业下，还有哪些是自己独有可以生存的？恐怕只有分布式的开发模式了，而这最后一个引以自豪的开发模式，微软这个巨人已经在大力借鉴和反击了，linux server app、docker、虚拟化、vscode, 微软在带领它庞大兵力的开发军团再比世界上90%的企业更快的迭代速度，在拥抱开源以及开源开发模式。 &emsp;&emsp;最令我害怕的不是微软这个巨人的觉醒，而是开源社区自身这种死不了也活不好的天然混沌，很多人说开源代码让我们可以站在前人的肩膀上发展，减少代码重复。&emsp;&emsp;而这么多年我看到的确实另外一番景象： &emsp;&emsp;因为力量不集中和个人开发者的资源和精力不够，大多数开源项目都是在现有大项目（商业公司背后开发）的基础上小修小补或者fork一些小项目供自己练手，当自己精力和资源不够时，一个小项目就中途断了，然后等下一个学生学习后再次折腾类似的技术。&emsp;&emsp;对，因为开放源代码，我们折腾的时候不用自己造前人的代码，但是这个世界上真的有多少超大的开源项目不靠商业公司雇员，纯粹靠开源模式长久发展下去的呢？ &emsp;&emsp;在我看来，开源社区最开始的大规模分布式开发模式确实对传统的大教堂集中开发模式产生了巨大的冲击和创新，但是当大教堂（公司）也学会集市（社区）开发模式后，真正拼资源和黑科技的时候，现今的开源社区面临着后劲不足的挑战，而大部分生在开源社区的人却不愿意看到这一点，还在拼死嘴犟。 &emsp;&emsp;Tower的古灵今年在WHLUG上说了一句话，我至今还在回味： &emsp;&emsp;大教堂和集市是否永远都应该在对立面？&emsp;&emsp;面对越来越多大教堂学习集市开发模式的商业趋势下，生在集市的这些开源个人英雄们是不是应该在更广阔的视角去思考开源的未来呢？ &emsp;&emsp;说实话，我更害怕将来的大教堂军团会用集市战术把开源社区的这些残存的游击队剿杀，更希望开源社区的每个人用更广阔的视角（并非只是技术）去审视未来，集中资源不要内耗，造一些真正的杀手锏武器来对抗大教堂军团。 &emsp;&emsp;未来怎么走？&emsp;&emsp;生在开源社区，我了解开源社区的优点，也了解它的缺点，正是因为了解的多更感到害怕，下面是我个人对开源社区的建议，我分为感性和理性两个方面，感性是我看到和担心的地方，理性是我以及deepin团队正在做的事情。 &emsp;&emsp;感性的建议&emsp;&emsp;感性的建议给开源社区的每个开发者们，这些话说出来可能很难听，或者很难接受，但从我个人的角度看，却无比真实，如果你觉得被冒犯了，请你不再生气的时候再看一遍，希望你能够理解。 &emsp;&emsp;除了技术强大外，我们不能变成只会电脑的傻子&emsp;&emsp;现在这个时代，在我看来，大多数人的知识和认知被同化的太严重了，尤其是开发者。为什么这么说？我亲爱的开发者们，你们每天都会看各种API文档、技术原理文章，定期都会主动看计算机专业书籍。但是从个人视野和更广阔的方面看，你们多久会看一本非计算机的书籍呢？多久会和你完全不同出生或背景的人深入探讨交叉科学的问题呢？而现在的互联网时代就像一个快餐连锁店一样，不断的烹制一代又一代的快餐和理论，让所有人放弃自己独立思考的个性，去追求各种互联网成功理论、赚快钱的方式、一套一套的套路解析，仿佛如果一个人，不了解现代商业和赚钱的套路就是傻子一样，而开发者这类追寻知识和一定要明白的人群却最享受各种商业模式和套路解析的文章，殊不知知道了理论如果不认同商业的本质和商业带来的牺牲外，除了变成吃饭时吹牛逼的谈资外，并不会给开发者带来快钱，反而会让开发者过得困惑和浮躁无比。因为这个时代塞给开发者太多本不属于他们这个群体的知识、套路和生活。而我认为开发者是介于科学家和艺术家的交叉艺术，开源开发者更是在独立思想上更优秀的一群人。 &emsp;&emsp;如果大多数的开发者不看更多的书，从思想上对开源有更深刻的理解，仅仅技术是无法给开源社区提供更多元化的发展思路和创新。 &emsp;&emsp;给自由软件争气，不要成为披着开源精神的恐怖分子&emsp;&emsp;曾经有幸和UCloud的老季吃饭，他的一句话我还是很受用的，大家都在讨论如果我这辈子生在美帝多好，而不要生活在中国，忍受这一切。他说： &emsp;&emsp;中国很多地方还需要提升，还有很多问题需要解决，如果十年后中国还没有发生改变，我觉得我就白做中国人了 &emsp;&emsp;开源开发者都是非常有原则的人， 大家都想达到理想国，但是既然现在不理想，请不要愚蠢的只会释放愤怒，好好学习本身就是一种力量，如果我们大家都好好学习，好好努力，非技术人员永远都是敬仰创造更多价值让世界变得更好的人，特别是开源本身还带有很多神秘感。如果我们大家放下我们自己的技术炫耀、放下我们自己的技术偏见、教条压迫，用更开阔的视野去看待和包容更多事情，我相信及时在中国这种物质限制的社会条件下，开源都会有快速发展的时代。 &emsp;&emsp;接受屎一般的世界，你才能去清除这个世界的肮脏&emsp;&emsp;这是我最近在想清楚的一点， 大多数玩开源的人都足够聪明，很多时候阻碍大家行动的不仅仅是逃避，而是想清楚以后不愿去脏自己手去铲屎的矫情，一整个群体的不好意思催生了更多无谓的自我失控，社区开发者自身的矫情才是开源社区发展的最大敌人。 &emsp;&emsp;明明一件事情可以快速做好，非要自己先YY一个牢笼出来，然后自己禁锢自己，觉得如果这样写代码，就会让某个用户在极限条件下出问题，而真实场景下，根本就不会有这样的事情发生，全部是开发者自己幻想出来的场景。 &emsp;&emsp;另外一个例子就是，比如Linux的依赖问题，如果要达到系统升级稳定和生态爆炸发展，就需要一种技术做到微软和苹果的那种runtime出来，runtime来保障应用API的稳定和环境稳定，操作系统本身只针对硬件和底层技术革新。要从Linux到达这种技术，就需要走很多弯路、workaround甚至是非常脏的方法，因为Linux设计时就是按照依赖方式做的。从技术上当然不好做，但是并不是做不到，苹果基于BSD就构建了成功的参考例子。但是从开发者本身来说，要不就找借口说很麻烦没有意义，要不就是从开发者自己是使用者的角度去反正这样做没有意义，或者系统升级稳定和隔离不是问题。 &emsp;&emsp;开发者是离强迫症患者最近的人群，开发者考虑问题的时候希望所有的事情都是井井有条，逻辑严密的，如果一条道路或者解决方案只要 “不完美” 或者 “不能解决所有问题” 或者 “不能符合自己的使用习惯” ， 这条道路就是行不通的。 &emsp;&emsp;我就举几个简单的例子： &emsp;&emsp;wayland这么多年，不去解决自身产品的问题、不解决高性能的应用场景（游戏或专用设备）的生态，天天用wayland就是理论性能最好的技术去吹嘘，甚至去咒骂英伟达，wayland技术最终如果无法促进先考的销售，没有钱能够养员工的情况下，谁有原生动力去做？难道redhat出钱去养英伟达的员工和家人吗？反过来，当年 Id Software 通过商业成功，最终还反而推进了DX在很多技术上的革新&emsp;&emsp;flatpak和snap发展，软件包格式对于用户没有意义，唯有包格式的runtime+应用商店+系统升级，三个维度同时做好才能达到 flatpak 所设想的理想技术境界，因为用户只会为了稳定、易用、方便而埋单的，而不仅仅只是折腾软件打包技术&emsp;&emsp;systemd 这么好的技术，能够让系统服务并行启动加速电脑启动速度，这种对用户来说就是体验好的技术却因为和老派开发者自己配置系统服务的习惯不一样遭受各种不公平的排挤&emsp;&emsp;这几年我想清楚了，阻碍开发者个人发展甚至影响到开源社区整个开发观念最大的障碍就是，开发者需要接受一种由不完美到完美渐进发展的开发模式，如果大家做任何开源项目的初期，都是抱着完美的、鸡蛋中挑骨头、站着说话不腰疼的混蛋模式去看待问题，开源社区很难发展壮大，因为辛苦做事情的人总是被没有包容性的人吐槽得没有任何前进的动力。 &emsp;&emsp;因为世界本来就是不完美、有瑕疵甚至肮脏的，只有极少的开发者在屎一样的世界做清除和构建工作，而更多的混蛋只会站在一边嫌臭 &emsp;&emsp;理性的建议&emsp;&emsp;理性的建议是从deepin团队自身的经验出发，希望可以给别的开源社区团队有一定的参考作用。 &emsp;&emsp;笨方法，只有航母舰队可以打败航母舰队&emsp;&emsp;全世界都在笑deepin造轮子，我笑全世界的开发者都只看到轮子，却不知道deepin造的是航母舰队。&emsp;&emsp;微软、苹果和安卓作为操作系统最大的航母舰队，他们有： &emsp;&emsp;几十款高质量的、设计统一的预装应用，我们就也把系统预装的应用造一遍&emsp;&emsp;它们有 .Net/COM 设计，我们就基于 FlatPak 发展runtime，把应用和系统彻底分开&emsp;&emsp;它们有系统原子更新，更新系统就像Docker一样快速和稳定，深度也要打造一套再也不用依赖软件包就可以轻松升级的系统&emsp;&emsp;苹果有牛逼的应用商店，深度也要做一套&emsp;&emsp;它们都有各自的杀手锏应用，深度也会做一套&emsp;&emsp;…&emsp;&emsp;因为我们总有一天会让那些笑话我们造轮子的人自己笑自己，因为那些嘲笑我们的人，根本就不知道什么叫用户体验，什么叫战略布局，因为那些嘲笑我们的人，只会人云亦云的说那些老掉牙的理论，却从来不知道怎么做到商业成功。 &emsp;&emsp;更快的产品迭代速度和社区协作模式&emsp;&emsp;微软、苹果已经发展了这么多年，人比我们多、钱比我们多、产品还比我们功能多，怎么办？&emsp;&emsp;只有更快的追呗，他们两年发一个版本，我们就一年发三个版本。 &emsp;&emsp;他们还在犹豫要不要改东西的时候，我们就已经收集完建议、马上讨论设计方案都更新出去了。 &emsp;&emsp;没错，方法就是这么简单暴力，这么笨，闪电侠的速度来移动大山，越难的事情我们越兴奋。 &emsp;&emsp;建立更为广阔的商业利益共同体&emsp;&emsp;既然微软和苹果最大围墙就是生态，世界那么大，一定能养活我们。&emsp;&emsp;我们不怕在微软的市场上和他们正面竞争（丢什么都不能丢骨气），我们自己也要在更多微软没有涉及到的领域发展自己的利益共同体和生态（这个世界不仅仅是互联网看到的地方才叫市场）。 &emsp;&emsp;保持耐心、初心和远见&emsp;&emsp;在赚钱的路上操练军队，要相信广阔的市场，一定会在我们自己足够强大时，让我们数十年的技术和产品积累在更多领域大放异彩。 &emsp;&emsp;星星之火可以燎原&emsp;&emsp;一位阿里的朋友的话，送给看到最后的朋友： &emsp;&emsp;既要仰望星空，又要脚踏实地 &emsp;&emsp;本文最初发表在www.jianshu.com，文章内容属作者个人观点]]></content>
      <categories>
        <category>文章佳句</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行提示符PS1及oh my zsh]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E7%A4%BA%E7%AC%A6PS1%E5%8F%8Aoh-my-zsh%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;PS1是Linux终端用户的一个环境变量，用来定义命令行提示符的参数。 &emsp;&emsp;在终端输入如下命令查看PS1的值： 1echo $PS1 &emsp;&emsp;我的PS1的值为 1\[\e[1;34m\][\[\e[1;31m\]\u\[\e[1;34m\]@\[\e[1;32m\]\h \[\e[1;33m\]\w \[\e[1;36m\]\A \[\e[1;34m\]#\[\e[1;35m\]\#\[\e[1;34m\]]\[\e[1;31m\]$\[\e[0m\] &emsp;&emsp;不过这是带了颜色设置的PS1，简化后为： 1[\u@\h \w \A #\#]\$ &emsp;&emsp;下面来说一说，PS1常用参数及含义： &emsp;&emsp;&emsp; \d : 代表日期 \H : 完整的主机名 \h : 仅取主机的第一个名字 \t : 显示时间为24小时格式，如 ： HH：MM：SS \T : 显示时间为12小时格式 \A : 显示时间为24小时格式，如：HH：MM \u : 显示当前用户账号名称 \v : BASH版本信息 \w: 完整的工作目录名称 \W: 利用basename取得的工作目录名称，只显示最后一个目录名 \# : 键入的第几个命令 \$ : 提示字符，root用户为#，普通用户为$ &emsp;&emsp;再说一说PS1的颜色设置。 &emsp;&emsp;在PS1中设置颜色的格式为：[\e[F;Bm]……[\e[0m]，其中”F”为字体颜色，编号为30-37，”B”为背景颜色，编号为40-47,[\e[0m]作为颜色设定的结束。其实\e可以换成\033,本质就是BASH中echo输出颜色的设置。 &emsp;&emsp;颜色对照表： 字体颜色(F) 背景色(B) 颜色 30 40 黑色 31 41 红色 32 41 绿色 33 43 黄色 34 44 蓝色 35 45 紫红色 36 46 青紫色 37 47 白色 &emsp;&emsp;还有几个特殊的代码设置： 代码 意义 0 OFF 1 高亮显示 4 underline 7 反白显示 8 不可见 &emsp;&emsp;我的效果图图下： &emsp;&emsp;本人的PS1设置放在了/etc/bashrc文件中，这样你在切换用户或启用子BASH时，BASH会重新读取/etc/bashrc文件，PS1的值不会改变，提示符特效也不会消失。 &emsp;&emsp; 佛祖保佑提示可以在/etc/motd文件中设置，只需以文本的格式输入你想显示的值。 &emsp;&emsp; 登录提示可以在/etc/bashrc中设置，只需在文件结尾加上如下几行： 123ip=`who am i | awk '&#123;print $6&#125;'| sed 's/(//g' | sed 's/)//g'`echo -n -e "\e[1;32mHi \e[1;31m$USER \e[1;32mWelcome to login. Now is \e[1;33m`date`\e[0m "echo -e " \e[1;32mAnd your IP is \e[1;36m$ip \e[1;32mHave a good time!\e[0m" &emsp;&emsp; 如此一来，就可以在登录或者切换用户时显示ip提示，佛像只有在登录时才会显示，因为只有登录才会读取 /etc/motd文件。 &emsp;&emsp;补充一下bash的自动补全软件：bash-completion ，CentOS上直接yum安装即可： 1yum install -y bash-completion &emsp;&emsp;另外可以使用oh my zsh来提高自动补全功能,比bash更强大，相应配置更复杂带有一些小问题，但并不妨碍我对他的喜爱，使用random主题可以随机呈现PS1的多彩效果，例如 &emsp;&emsp;oh my zsh使用默认配置即可，主题可在~/.zshrc中 ZSH_THEME=”random” 处更改，其安装如下： 1sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" &emsp;&emsp;可使用 chsh 改变默认shell为zsh，更新oh my zsh请使用 upgrade_oh_my_zsh 命令，卸载使用 uninstall_oh_my_zsh 命令。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人的vim配置：.vimrc]]></title>
    <url>%2F2018%2F07%2F11%2F%E4%B8%AA%E4%BA%BA%E7%9A%84vim%E9%85%8D%E7%BD%AE%EF%BC%9A-vimrc%2F</url>
    <content type="text"><![CDATA[主题用的是 monokai 插件管理用的是 Vundle C/C++自动补全插件 YouCompleteMe 状态栏插件 vim-powerline 全局搜索插件 ctrlp.vim 项目树插件 NERDTree 折叠插件 SimpylFold 显示文件标签插件 tagbar 彩虹括号 rainbow 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273" Vundleset nocompatible " be iMproved, requiredfiletype off " required" set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()" alternatively, pass a path where Vundle should install plugins"call vundle#begin('~/some/path/here')" let Vundle manage Vundle, requiredPlugin 'VundleVim/Vundle.vim'" The following are examples of different formats supported." Keep Plugin commands between vundle#begin/end." plugin on GitHub repoPlugin 'tpope/vim-fugitive'" plugin from http://vim-scripts.org/vim/scripts.html" Plugin 'L9'" Git plugin not hosted on GitHub""Plugin 'git://git.wincent.com/command-t.git'" git repos on your local machine (i.e. when working on your own plugin)""Plugin 'file:///home/gmrik/path/to/plugin'" The sparkup vim script is in a subdirectory of this repo called vim." Pass the path to set the runtimepath properly." Plugin 'altercation/vim-colors-solarized'Plugin 'tmhedberg/SimpylFold'Plugin 'kien/ctrlp.vim'Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;Plugin 'vim-scripts/OmniCppComplete'Plugin 'Valloric/YouCompleteMe'Plugin 'ascenator/L9', &#123;'name': 'newL9'&#125;Bundle "Lokaltog/vim-powerline"Bundle "tdcdev/ycm_simple_conf"Plugin 'luochen1990/rainbow'Plugin 'scrooloose/nerdtree'Plugin 'jistr/vim-nerdtree-tabs'Bundle 'majutsushi/tagbar'" All of your Plugins must be added before the following linecall vundle#end() " requiredfiletype plugin indent on " required" To ignore plugin indent changes, instead use:"filetype plugin on"" Brief help" :PluginList - lists configured plugins" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate" :PluginSearch foo - searches for foo; append `!` to refresh local cache" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal"" see :h vundle for more details or wiki for FAQ" Put your non-Plugin stuff after this line" 主题"colorscheme morning "colorscheme desert "colorscheme solarized"colorscheme roncolorscheme monokaiset background=dark" 256颜色支持set t_Co=256" 编码set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8set fileencodings=ucs-bom,utf-8,cp936set fileencoding=utf-8"语言设置set langmenu=zh_CN.UTF-8set helplang=cn"""""""""""""""""""""""""""""""""""""""""""""""""""" 显示相关 """""""""""""""""""""""""""""""""""""""""""""""""""" 不显示援助乌干达儿童的提示set shortmess=atI" 取消图形按钮set go= " 语法高亮syntax enablesyntax on" 用浅色高亮当前行autocmd InsertLeave * se nocul" 用浅色高亮当前行autocmd InsertEnter * se cul" 显示标尺set ruler " 显示输入命令set showcmd " 不要闪烁set novisualbell" 状态栏" 启动显示状态行(1),总是显示状态行(2)set laststatus=2let g:Powerline_symbols='unicode'"去掉vi一致性模式set nocompatible" 显示中文帮助if version &gt;= 603 set helplang=cn set encoding=utf-8endif"""""""""""""""""""""""""""""""""""""""""""""""""""""""" 键盘命令"""""""""""""""""""""""""""""""""""""""""""""""""""""""nmap &lt;leader&gt;w :w!&lt;cr&gt;nmap &lt;leader&gt;f :find&lt;cr&gt;" Open a NERDTreenmap &lt;F3&gt; :NERDTreeToggle&lt;cr&gt;" Tagbarnmap &lt;F4&gt; :TagbarToggle&lt;CR&gt;"C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc() exec "w" if &amp;filetype == 'c' exec "!g++ % -o %&lt;" exec "! ./%&lt;" elseif &amp;filetype == 'cpp' exec "!g++ % -o %&lt;" exec "! ./%&lt;" elseif &amp;filetype == 'java' exec "!javac %" exec "!java %&lt;" elseif &amp;filetype == 'sh' :!./% elseif &amp;filetype == 'py' exec "!python %" exec "!python %&lt;" endifendfunc"C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb() exec "w" exec "!g++ % -g -o %&lt;" exec "!gdb ./%&lt;"endfunc"设置粘贴set pastetoggle=&lt;F11&gt;map &lt;F12&gt; gg=G""""""""""""""""""""""""""""""""""""""""""""""""""" 实用设置""""""""""""""""""""""""""""""""""""""""""""""""""" 设置当文件被改动时自动载入set autoread" quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;" 补全行为与IDE一致 set completeopt=preview,menu,longest " 允许插件 filetype plugin on" 共享剪贴板 set clipboard+=unnamed " 从不备份 set nobackup" make 运行:set makeprg=g++\ -Wall\ \ %" 自动保存set autowrite" 在处理未保存或只读文件的时候，弹出确认set confirm" 自动缩进set autoindentset cindent" Tab键的宽度set tabstop=4" 统一缩进为4set softtabstop=4set shiftwidth=4" 不要用空格代替制表符set noexpandtab" 在行和段开始处使用制表符set smarttab" 显示行号set number" 历史记录数set history=1000" 禁止生成临时文件set nobackupset noswapfile" 搜索忽略大小写set ignorecase" 搜索逐字符高亮set hlsearchset incsearch" 行内替换set gdefault" 命令行的高度，默认为1，这里是2set cmdheight=2" 侦测文件类型filetype on" 载入文件类型插件filetype plugin on" 为特定文件类型载入相关缩进文件filetype indent on" 保存全局变量set viminfo+=!" 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-" 字符间插入的像素行数目set linespace=0" 增强模式中的命令行自动完成操作set wildmenu" 使回格键（backspace）正常处理indent, eol, start等set backspace=2" 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l" 可以在buffer的任何地方使用鼠标set selection=exclusiveset selectmode=mouse,key" 在被分割的窗口间显示空白set fillchars=vert:\ ,stl:\ ,stlnc:\" 高亮显示匹配的括号set showmatch" 匹配括号高亮的时间set matchtime=1" 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3" C自动缩进set smartindent" 高亮显示普通txt文件au BufRead,BufNewFile * setfiletype txt" 括号自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;=ClosePair(')')&lt;CR&gt;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O:inoremap &#125; &lt;c-r&gt;=ClosePair('&#125;')&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;=ClosePair(']')&lt;CR&gt;:inoremap " ""&lt;ESC&gt;i:inoremap ' ''&lt;ESC&gt;ifunction! ClosePair(char) if getline('.')[col('.') - 1] == a:char return "\&lt;Right&gt;" else return a:char endifendfunction" NERD treelet NERDChristmasTree=0let NERDTreeWinSize=35let NERDTreeChDirMode=2let NERDTreeIgnore=['\~$', '\.pyc$', '\.swp$']let NERDTreeShowBookmarks=1let NERDTreeWinPos="left"" Automatically open a NERDTree if no files where specifiedautocmd vimenter * if !argc() | NERDTree | endif" Close vim if the only window left open is a NERDTreeautocmd bufenter * if (winnr("$") == 1 &amp;&amp; exists("b:NERDTreeType") &amp;&amp; b:NERDTreeType == "primary") | q | endif" 插件filetype plugin indent on " YouCompleteMelet g:ycm_global_ycm_extra_conf = '~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'" 关键字补全let g:ycm_seed_identifiers_with_syntax=1 " 不显示开启vim时检查ycm_extra_conf文件的信息let g:ycm_confirm_extra_conf=0" 每次重新生成匹配项，禁止缓存匹配项let g:ycm_cache_omnifunc=0" 输入第一个字符就开始补全let g:ycm_min_num_of_chars_for_completion=2" 在注释中也可以补全let g:ycm_complete_in_comments=1" 字符串补全let g:ycm_complete_in_strings=1" ycm_simple_conflet g:ycm_simple_conf_active = 0" Rainbow 彩虹括号let g:rainbow_active = 0" TagbarTogglelet g:tagbar_width=35let g:tagbar_autofocus=1]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卜算子·黄州定慧院寓居作 -苏轼]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%8D%9C%E7%AE%97%E5%AD%90%C2%B7%E9%BB%84%E5%B7%9E%E5%AE%9A%E6%85%A7%E9%99%A2%E5%AF%93%E5%B1%85%E4%BD%9C-%E8%8B%8F%E8%BD%BC%2F</url>
    <content type="text"><![CDATA[缺月挂疏桐，漏断人初静。谁见幽人独往来，缥缈孤鸿影。 惊起却回头，有恨无人省。 拣尽寒枝不肯栖，寂寞沙洲冷。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[念奴娇 赤壁怀古 -苏轼]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%BF%B5%E5%A5%B4%E5%A8%87-%E8%B5%A4%E5%A3%81%E6%80%80%E5%8F%A4-%E8%8B%8F%E8%BD%BC%2F</url>
    <content type="text"><![CDATA[大江东去，浪淘尽，千古风流人物。 故垒西边，人道是，三国周郎赤壁。 乱石穿空，惊涛拍岸，卷起千堆雪。 江山如画，一时多少豪杰。 遥想公瑾当年，小乔初嫁了，雄姿英发。 羽扇纶巾，谈笑间，樯橹灰飞烟灭。 故国神游，多情应笑我，早生华发。 人生如梦，一尊还酹江月。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木兰词·拟古决绝词柬友 -纳兰容若]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%9C%A8%E5%85%B0%E8%AF%8D%C2%B7%E6%8B%9F%E5%8F%A4%E5%86%B3%E7%BB%9D%E8%AF%8D%E6%9F%AC%E5%8F%8B-%E7%BA%B3%E5%85%B0%E5%AE%B9%E8%8B%A5%2F</url>
    <content type="text"><![CDATA[人生若只如初见，何事秋风悲画扇。等闲变却故人心，却道故人心易变。 骊山语罢清宵半，泪雨零铃终不怨。 何如薄幸锦衣郎，比翼连枝当日愿。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贺新郎·寄辛幼安和见怀韵 -陈亮]]></title>
    <url>%2F2018%2F07%2F11%2F%E8%B4%BA%E6%96%B0%E9%83%8E%C2%B7%E5%AF%84%E8%BE%9B%E5%B9%BC%E5%AE%89%E5%92%8C%E8%A7%81%E6%80%80%E9%9F%B5-%E9%99%88%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[老去凭谁说？看几番，神奇臭腐，夏裘冬葛！ 父老长安今余几？后死无仇可雪。 犹未燥，当时生发！ 二十五弦多少恨，算世间，那有平分月！ 胡妇弄，汉宫瑟。 树犹如此堪重别！ 只使君，从来与我，话头多合。 行矣置之无足问，谁换妍皮痴骨？ 但莫使伯牙弦绝！ 九转丹砂牢拾取，管精金，只是寻常铁。 龙共虎，应声裂。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水龙吟 登建康赏心亭 -辛弃疾]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%B0%B4%E9%BE%99%E5%90%9F-%E7%99%BB%E5%BB%BA%E5%BA%B7%E8%B5%8F%E5%BF%83%E4%BA%AD-%E8%BE%9B%E5%BC%83%E7%96%BE%2F</url>
    <content type="text"><![CDATA[楚天千里清秋，水随天去秋无际。遥岑远目，献愁供恨，玉簪螺髻。 落日楼头，断鸿声里，江南游子。 把吴钩看了，栏干拍遍， 无人会，登临意。 休说鲈鱼堪脍， 尽西风，季鹰归未？ 求田问舍，怕应羞见，刘郎才气。 可惜流年，忧愁风雨，树犹如此！ 倩何人唤取红巾翠袖， 揾英雄泪！]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破阵子·为陈同甫赋壮词以寄 辛弃疾]]></title>
    <url>%2F2018%2F07%2F11%2F%E7%A0%B4%E9%98%B5%E5%AD%90%C2%B7%E4%B8%BA%E9%99%88%E5%90%8C%E7%94%AB%E8%B5%8B%E5%A3%AE%E8%AF%8D%E4%BB%A5%E5%AF%84-%E8%BE%9B%E5%BC%83%E7%96%BE%2F</url>
    <content type="text"><![CDATA[醉里挑灯看剑，梦回吹角连营。八百里分麾下炙，五十弦翻塞外声。 沙场秋点兵。 马作的卢飞快，弓如霹雳弦惊。 了却君王天下事，赢得生前身后名。 可怜白发生！]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[永遇乐 京口北固亭怀古 -辛弃疾]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%B0%B8%E9%81%87%E4%B9%90-%E4%BA%AC%E5%8F%A3%E5%8C%97%E5%9B%BA%E4%BA%AD%E6%80%80%E5%8F%A4-%E8%BE%9B%E5%BC%83%E7%96%BE%2F</url>
    <content type="text"><![CDATA[千古江山，英雄无觅，孙仲谋处。 舞榭歌台，风流总被、雨打风吹去。 斜阳草树，寻常巷陌， 人道寄奴曾住。 想当年，金戈铁马，气吞万里如虎。 元嘉草草，封狼居胥， 赢得仓皇北顾。 四十三年，望中犹记，烽火扬州路。 可堪回首，佛狸祠下， 一片神鸦社鼓。 凭谁问：廉颇老矣，尚能饭否？]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[临江仙 -杨慎]]></title>
    <url>%2F2018%2F07%2F11%2F%E4%B8%B4%E6%B1%9F%E4%BB%99-%E6%9D%A8%E6%85%8E%2F</url>
    <content type="text"><![CDATA[滚滚长江东逝水，浪花淘尽英雄。 是非成败转头空。 青山依旧在，几度夕阳红。 白发渔樵江渚上，惯看秋月春风。 一壶浊酒喜相逢。 古今多少事，都付笑谈中。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[满江红·写怀 -岳飞]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%BB%A1%E6%B1%9F%E7%BA%A2%C2%B7%E5%86%99%E6%80%80-%E5%B2%B3%E9%A3%9E%2F</url>
    <content type="text"><![CDATA[怒发冲冠，凭栏处、潇潇雨歇。 抬望眼，仰天长啸，壮怀激烈。 三十功名尘与土，八千里路云和月。 莫等闲，白了少年头，空悲切！ 靖康耻，犹未雪。 臣子恨，何时灭！ 驾长车，踏破贺兰山缺。 壮志饥餐胡虏肉，笑谈渴饮匈奴血。 待从头、收拾旧山河，朝天阙。 &emsp;&emsp;]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侠客行 -李白]]></title>
    <url>%2F2018%2F07%2F11%2F%E4%BE%A0%E5%AE%A2%E8%A1%8C-%E6%9D%8E%E7%99%BD%2F</url>
    <content type="text"><![CDATA[赵客缦胡缨，吴钩霜雪明。 银鞍照白马，飒沓如流星。 十步杀一人，千里不留行。 事了拂衣去，深藏身与名。 闲过信陵饮，脱剑膝前横。 将炙啖朱亥，持觞劝侯嬴。 三杯吐然诺，五岳倒为轻。 眼花耳热后，意气素霓生。 救赵挥金锤，邯郸先震惊。 千秋二壮士，烜赫大梁城。 纵死侠骨香，不惭世上英。 谁能书阁下，白首太玄经。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岳阳楼记 –范仲淹]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%B2%B3%E9%98%B3%E6%A5%BC%E8%AE%B0-%E2%80%93%E8%8C%83%E4%BB%B2%E6%B7%B9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴。乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上。属予作文以记之。 &emsp;&emsp;予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯；朝晖夕阴，气象万千。此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？ &emsp;&emsp;若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空；日星隐曜，山岳潜形；商旅不行，樯倾楫摧；薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。 &emsp;&emsp;至若春和景明，波澜不惊，上下天光，一碧万顷；沙鸥翔集，锦鳞游泳；岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。 &emsp;&emsp;嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲；居庙堂之高则忧其民；处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎。噫！微斯人，吾谁与归？ &emsp;&emsp;时六年九月十五日。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[茅屋为秋风所破歌 –杜甫]]></title>
    <url>%2F2018%2F07%2F11%2F%E8%8C%85%E5%B1%8B%E4%B8%BA%E7%A7%8B%E9%A3%8E%E6%89%80%E7%A0%B4%E6%AD%8C-%E2%80%93%E6%9D%9C%E7%94%AB%2F</url>
    <content type="text"><![CDATA[八月秋高风怒号，卷我屋上三重茅。茅飞渡江洒江郊，高者挂罥长林梢，下者飘转沉塘坳。 南村群童欺我老无力，忍能对面为盗贼。 公然抱茅入竹去，唇焦口燥呼不得，归来倚杖自叹息。 俄顷风定云墨色，秋天漠漠向昏黑。 布衾多年冷似铁，娇儿恶卧踏里裂。 床头屋漏无干处，雨脚如麻未断绝。 自经丧乱少睡眠，长夜沾湿何由彻！ 安得广厦千万间，大庇天下寒士俱欢颜！ 风雨不动安如山。 呜呼！何时眼前突兀见此屋，吾庐独破受冻死亦足！ &emsp;&emsp;南村群童欺我老无力，忍能对面为盗贼。公然抱茅入竹去，唇焦口燥呼不得，归来倚杖自叹息。 &emsp;&emsp;俄顷风定云墨色，秋天漠漠向昏黑。布衾多年冷似铁，娇儿恶卧踏里裂。床头屋漏无干处，雨脚如麻未断绝。自经丧乱少睡眠，长夜沾湿何由彻！ &emsp;&emsp;安得广厦千万间，大庇天下寒士俱欢颜！风雨不动安如山。呜呼！何时眼前突兀见此屋，吾庐独破受冻死亦足！]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生于忧患死于安乐 –《孟子》]]></title>
    <url>%2F2018%2F07%2F11%2F%E7%94%9F%E4%BA%8E%E5%BF%A7%E6%82%A3%E6%AD%BB%E4%BA%8E%E5%AE%89%E4%B9%90-%E2%80%93%E3%80%8A%E5%AD%9F%E5%AD%90%E3%80%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;舜发于畎亩之中，傅说举于版筑之间，胶鬲举于鱼盐之中，管夷吾举于士，孙叔敖举于海，百里奚举于市，故天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。 &emsp;&emsp;人恒过，然后能改，困于心衡于虑而后作，征于色发于声而后喻。入则无法家拂士，出则无敌国外患者，国恒亡，然后知生于忧患而死于安乐也。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鱼我所欲也 -《孟子》]]></title>
    <url>%2F2018%2F07%2F11%2F%E9%B1%BC%E6%88%91%E6%89%80%E6%AC%B2%E4%B9%9F-%E3%80%8A%E5%AD%9F%E5%AD%90%E3%80%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;鱼，我所欲也；熊掌，亦我所欲也，二者不可得兼，舍鱼而取熊掌者也。生，亦我所欲也；义，亦我所欲也。二者不可得兼，舍生而取义者也。生亦我所欲，所欲有甚于生者，故不为苟得也。 死亦我所恶，所恶有甚于死者，故患有所不辟也。如使人之所欲莫甚于生，则凡可以得生者何不用也。使人之所恶莫甚于死者，则凡可以辟患者何不为也！由是则生而有不用也；由是则可以辟患而有不为也。是故所欲有甚于生者，所恶有甚于死者。非独贤者有是心也，人皆有之，贤者能勿丧耳。 &emsp;&emsp;一箪食，一豆羹，得之则生，弗得则死。呼尔而与之，行道之人弗受；蹴尔而与之，乞人不屑也。 &emsp;&emsp;万钟则不辩礼义而受之，万钟于我何加焉！为宫室之美，妻妾之奉，所识穷乏者得我与？乡为身死而不受，今为宫室之美为之；乡为身死而不受，今为妻妾之奉为之；乡为身死而不受，今为所识穷乏者得我而为之：是亦不可以已乎？此之谓失其本心。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿房宫赋 –杜牧]]></title>
    <url>%2F2018%2F07%2F11%2F%E9%98%BF%E6%88%BF%E5%AE%AB%E8%B5%8B-%E2%80%93%E6%9D%9C%E7%89%A7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;六王毕，四海一，蜀山兀，阿房出。覆压三百余里，隔离天日。骊山北构而西折，直走咸阳。二川溶溶，流入宫墙。五步一楼，十步一阁；廊腰缦回，檐牙高啄；各抱地势，钩心斗角。盘盘焉，囷囷焉，蜂房水涡，矗不知其几千万落。长桥卧波，未云何龙？复道行空，不霁何虹？高低冥迷，不知西东。歌台暖响，春光融融；舞殿冷袖，风雨凄凄。一日之内，一宫之间，而气候不齐。 &emsp;&emsp;妃嫔媵嫱，王子皇孙，辞楼下殿，辇来于秦，朝歌夜弦，为秦宫人。明星荧荧，开妆镜也；绿云扰扰，梳晓鬟也；渭流涨腻，弃脂水也；烟斜雾横，焚椒兰也。雷霆乍惊，宫车过也；辘辘远听，杳不知其所之也。一肌一容，尽态极妍，缦立远视，而望幸焉。有不见者，三十六年。(有不见者 一作：有不得见者)燕赵之收藏，韩魏之经营，齐楚之精英，几世几年，剽掠其人，倚叠如山。一旦不能有，输来其间。鼎铛玉石，金块珠砾，弃掷逦迤，秦人视之，亦不甚惜。 &emsp;&emsp;嗟乎！一人之心，千万人之心也。秦爱纷奢，人亦念其家。奈何取之尽锱铢，用之如泥沙！使负栋之柱，多于南亩之农夫；架梁之椽，多于机上之工女；钉头磷磷，多于在庾之粟粒；瓦缝参差，多于周身之帛缕；直栏横槛，多于九土之城郭；管弦呕哑，多于市人之言语。使天下之人，不敢言而敢怒。独夫之心，日益骄固。戍卒叫，函谷举，楚人一炬，可怜焦土！ &emsp;&emsp;呜呼！灭六国者六国也，非秦也；族秦者秦也，非天下也。嗟乎！使六国各爱其人，则足以拒秦；使秦复爱六国之人，则递三世可至万世而为君，谁得而族灭也？秦人不暇自哀，而后人哀之；后人哀之而不鉴之，亦使后人而复哀后人也。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逍遥游 –庄周]]></title>
    <url>%2F2018%2F07%2F11%2F%E9%80%8D%E9%81%A5%E6%B8%B8-%E2%80%93%E5%BA%84%E5%91%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;北冥有鱼，其名为鲲。鲲之大，不知其几千里也。化而为鸟，其名为鹏。鹏之背，不知其几千里也，怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。 《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天而莫之夭阏者，而后乃今将图南。 &emsp;&emsp;蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者宿舂粮，适千里者，三月聚粮。之二虫又何知？(抢榆枋 一作：枪榆枋) &emsp;&emsp;小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋。上古有大椿者，以八千岁为春，八千岁为秋。此大年也。而彭祖乃今以久特闻，众人匹之。不亦悲乎！ &emsp;&emsp;汤之问棘也是已：“穷发之北有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏。背若泰山，翼若垂天之云。抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。斥鷃笑之曰：‘彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也。而彼且奚适也？’”此小大之辩也。 &emsp;&emsp;故夫知效一官，行比一乡，德合一君，而征一国者，其自视也亦若此矣。而宋荣子犹然笑之。且举世誉之而不加劝，举世非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。夫列子御风而行，泠然善也。旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陈情表 –陈密]]></title>
    <url>%2F2018%2F07%2F11%2F%E9%99%88%E6%83%85%E8%A1%A8-%E2%80%93%E9%99%88%E5%AF%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 臣密言：臣以险衅，夙遭闵凶。生孩六月，慈父见背；行年四岁，舅夺母志。祖母刘悯臣孤弱，躬亲抚养。臣少多疾病，九岁不行，零丁孤苦，至于成立。既无叔伯，终鲜兄弟，门衰祚薄，晚有儿息。外无期功强近之亲，内无应门五尺之僮，茕茕孑立，形影相吊。而刘夙婴疾病，常在床蓐，臣侍汤药，未曾废离。 &emsp;&emsp;逮奉圣朝，沐浴清化。前太守臣逵察臣孝廉，后刺史臣荣举臣秀才。臣以供养无主，辞不赴命。诏书特下，拜臣郎中，寻蒙国恩，除臣洗马。猥以微贱，当侍东宫，非臣陨首所能上报。臣具以表闻，辞不就职。诏书切峻，责臣逋慢。郡县逼迫，催臣上道；州司临门，急于星火。臣欲奉诏奔驰，则刘病日笃；欲苟顺私情，则告诉不许：臣之进退，实为狼狈。 &emsp;&emsp;伏惟圣朝以孝治天下，凡在故老，犹蒙矜育，况臣孤苦，特为尤甚。且臣少仕伪朝，历职郎署，本图宦达，不矜名节。今臣亡国贱俘，至微至陋，过蒙拔擢，宠命优渥，岂敢盘桓，有所希冀。但以刘日薄西山，气息奄奄，人命危浅，朝不虑夕。臣无祖母，无以至今日；祖母无臣，无以终余年。母、孙二人，更相为命，是以区区不能废远。 &emsp;&emsp;臣密今年四十有四，祖母刘今年九十有六，是臣尽节于陛下之日长，报养刘之日短也。乌鸟私情，愿乞终养。臣之辛苦，非独蜀之人士及二州牧伯所见明知，皇天后土，实所共鉴。愿陛下矜悯愚诚，听臣微志，庶刘侥幸，保卒余年。臣生当陨首，死当结草。臣不胜犬马怖惧之情，谨拜表以闻。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项脊轩志 -归有光]]></title>
    <url>%2F2018%2F07%2F11%2F%E9%A1%B9%E8%84%8A%E8%BD%A9%E5%BF%97-%E5%BD%92%E6%9C%89%E5%85%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;项脊轩，旧南阁子也。室仅方丈，可容一人居。百年老屋，尘泥渗漉，雨泽下注；每移案，顾视，无可置者。又北向，不能得日，日过午已昏。余稍为修葺，使不上漏。前辟四窗，垣墙周庭，以当南日，日影反照，室始洞然。又杂植兰桂竹木于庭，旧时栏楯，亦遂增胜。借书满架，偃仰啸歌，冥然兀坐，万籁有声；而庭堦寂寂，小鸟时来啄食，人至不去。三五之夜，明月半墙，桂影斑驳，风移影动，珊珊可爱。 &emsp;&emsp;然余居于此，多可喜，亦多可悲。先是庭中通南北为一。迨诸父异爨(cuàn)，内外多置小门，墙往往而是。东犬西吠，客逾庖而宴，鸡栖于厅。庭中始为篱，已为墙，凡再变矣。家有老妪，尝居于此。妪，先大母婢也，乳二世，先妣抚之甚厚。室西连于中闺，先妣尝一至。妪每谓余曰：”某所，而母立于兹。”妪又曰：”汝姊在吾怀，呱呱而泣；娘以指叩门扉曰：‘儿寒乎？欲食乎？’吾从板外相为应答。”语未毕，余泣，妪亦泣。余自束发，读书轩中，一日，大母过余曰：”吾儿，久不见若影，何竟日默默在此，大类女郎也？”比去，以手阖门，自语曰：”吾家读书久不效，儿之成，则可待乎！”顷之，持一象笏至，曰：”此吾祖太常公宣德间执此以朝，他日汝当用之！”瞻顾遗迹，如在昨日，令人长号不自禁。 轩东，故尝为厨，人往，从轩前过。余扃牖(jiōng yǒu)而居，久之，能以足音辨人。轩凡四遭火，得不焚，殆有神护者。 &emsp;&emsp;项脊生曰：”蜀清守丹穴，利甲天下，其后秦皇帝筑女怀清台；刘玄德与曹操争天下，诸葛孔明起陇中。方二人之昧昧于一隅也，世何足以知之，余区区处败屋中，方扬眉、瞬目，谓有奇景。人知之者，其谓与坎井之蛙何异？” &emsp;&emsp;余既为此志，后五年，吾妻来归，时至轩中，从余问古事，或凭几学书。吾妻归宁，述诸小妹语曰：”闻姊家有阁子，且何谓阁子也？”其后六年，吾妻死，室坏不修。其后二年，余久卧病无聊，乃使人复葺南阁子，其制稍异于前。然自后余多在外，不常居。 &emsp;&emsp;庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滕王阁序 –王勃]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F-%E2%80%93%E7%8E%8B%E5%8B%83%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。 &emsp;&emsp; 时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。 &emsp;&emsp;披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。 &emsp;&emsp;遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？ &emsp;&emsp;嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！ &emsp;&emsp;勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？ &emsp;&emsp;呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔： &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;滕王高阁临江渚，佩玉鸣鸾罢歌舞。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;画栋朝飞南浦云，珠帘暮卷西山雨。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;闲云潭影日悠悠，物换星移几度秋。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;阁中帝子今何在？槛外长江空自流。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祭十二郎文 –韩愈]]></title>
    <url>%2F2018%2F07%2F11%2F%E7%A5%AD%E5%8D%81%E4%BA%8C%E9%83%8E%E6%96%87-%E2%80%93%E9%9F%A9%E6%84%88%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;年、月、日，季父愈闻汝丧之七日，乃能衔哀致诚，使建中远具时羞之奠，告汝十二郎之灵： &emsp;&emsp;呜呼！吾少孤，及长，不省所怙，惟兄嫂是依。中年，兄殁南方，吾与汝俱幼，从嫂归葬河阳。既又与汝就食江南。零丁孤苦，未尝一日相离也。吾上有三兄，皆不幸早世。承先人后者，在孙惟汝，在子惟吾。两世一身，形单影只。嫂尝抚汝指吾而言曰：“韩氏两世，惟此而已！”汝时尤小，当不复记忆。吾时虽能记忆，亦未知其言之悲也。 &emsp;&emsp;吾年十九，始来京城。其后四年，而归视汝。又四年，吾往河阳省坟墓，遇汝从嫂丧来葬。又二年，吾佐董丞相于汴州，汝来省吾。止一岁，请归取其孥。明年，丞相薨。吾去汴州，汝不果来。是年，吾佐戎徐州，使取汝者始行，吾又罢去，汝又不果来。吾念汝从于东，东亦客也，不可以久；图久远者，莫如西归，将成家而致汝。呜呼！孰谓汝遽去吾而殁乎！吾与汝俱少年，以为虽暂相别，终当久相与处。故舍汝而旅食京师，以求斗斛之禄。诚知其如此，虽万乘之公相，吾不以一日辍汝而就也。 &emsp;&emsp;去年，孟东野往。吾书与汝曰：“吾年未四十，而视茫茫，而发苍苍，而齿牙动摇。念诸父与诸兄，皆康强而早世。如吾之衰者，其能久存乎？吾不可去，汝不肯来，恐旦暮死，而汝抱无涯之戚也！”孰谓少者殁而长者存，强者夭而病者全乎！ &emsp;&emsp;呜呼！其信然邪？其梦邪？其传之非其真邪？信也，吾兄之盛德而夭其嗣乎？汝之纯明而不克蒙其泽乎？少者、强者而夭殁，长者、衰者而存全乎？未可以为信也。梦也，传之非其真也，东野之书，耿兰之报，何为而在吾侧也？呜呼！其信然矣！吾兄之盛德而夭其嗣矣！汝之纯明宜业其家者，而不克蒙其泽！所谓天者诚难测，而神者诚难明矣！所谓理者不可推，而寿者不可知矣！ &emsp;&emsp;虽然，吾自今年来，苍苍者或化而为白矣，动摇者或脱而落矣。毛血日益衰，志气日益微，几何不从汝而死也。死而有知，其几何离；其无知，悲不几时，而不悲者无穷期矣。 &emsp;&emsp;汝之子始十岁，吾之子始五岁。少而强者不可保，如此孩提者，又可冀其成立邪？呜呼哀哉！呜呼哀哉！ &emsp;&emsp;汝去年书云：“比得软脚病，往往而剧。”吾曰：“是疾也，江南之人，常常有之。”未始以为忧也。呜呼！其竟以此而殒其生乎？抑别有疾而至斯极乎？ 汝之书，六月十七日也。东野云，汝殁以六月二日；耿兰之报无月日。盖东野之使者，不知问家人以月日；如耿兰之报，不知当言月日。东野与吾书，乃问使者，使者妄称以应之乎。其然乎？其不然乎？ &emsp;&emsp;吾使建中祭汝，吊汝之孤与汝之乳母。彼有食，可守以待终丧，则待终丧而取以来；如不能守以终丧，则遂取以来。其余奴婢，并令守汝丧。吾力能改葬，终葬汝于先人之兆，然后惟其所愿。 &emsp;&emsp; 呜呼！汝病吾不知时，汝殁吾不知日，生不能相养于共居，殁不得抚汝以尽哀，敛不凭其棺，窆不临其穴。吾行负神明，而使汝夭；不孝不慈，而不能与汝相养以生，相守以死。一在天之涯，一在地之角，生而影不与吾形相依，死而魂不与吾梦相接。吾实为之，其又何尤！彼苍者天，曷其有极！自今已往，吾其无意于人世矣！当求数顷之田于伊颍之上，以待余年，教吾子与汝子，幸其成；长吾女与汝女，待其嫁，如此而已。 &emsp;&emsp;呜呼，言有穷而情不可终，汝其知也邪？其不知也邪？呜呼哀哉！尚飨！]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正气歌 –文天祥]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%AD%A3%E6%B0%94%E6%AD%8C-%E2%80%93%E6%96%87%E5%A4%A9%E7%A5%A5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;余囚北庭，坐一土室。室广八尺，深可四寻。单扉低小，白间短窄，污下而幽暗。当此夏日，诸气萃然：雨潦四集，浮动床几，时则为水气； 涂泥半朝，蒸沤历澜，时则为土气；乍晴暴热，风道四塞，时则为日气；檐阴薪爨，助长炎虐，时则为火气；仓腐寄顿，陈陈逼人，时则为米气；骈肩杂遝，腥臊汗垢，时则为人气；或圊溷、或毁尸、或腐鼠，恶气杂出，时则为秽气。叠是数气，当之者鲜不为厉。而予以孱弱，俯仰其间，於兹二年矣，幸而无恙，是殆有养致然尔。然亦安知所养何哉？孟子曰：「吾善养吾浩然之气。」彼气有七，吾气有一，以一敌七，吾何患焉！况浩然者，乃天地之正气也，作正气歌一首。 &emsp;&emsp;天地有正气，杂然赋流形。下则为河岳，上则为日星。於人曰浩然，沛乎塞苍冥。 &emsp;&emsp;皇路当清夷，含和吐明庭。时穷节乃见，一一垂丹青。在齐太史简，在晋董狐笔。 &emsp;&emsp;在秦张良椎，在汉苏武节。为严将军头，为嵇侍中血。为张睢阳齿，为颜常山舌。 &emsp;&emsp;或为辽东帽，清操厉冰雪。或为出师表，鬼神泣壮烈。或为渡江楫，慷慨吞胡羯。 &emsp;&emsp;或为击贼笏，逆竖头破裂。是气所磅礴，凛烈万古存。当其贯日月，生死安足论。 &emsp;&emsp;地维赖以立，天柱赖以尊。三纲实系命，道义为之根。嗟予遘阳九，隶也实不力。 &emsp;&emsp;楚囚缨其冠，传车送穷北。鼎镬甘如饴，求之不可得。阴房阗鬼火，春院闭天黑。 &emsp;&emsp;牛骥同一皂，鸡栖凤凰食。一朝蒙雾露，分作沟中瘠。如此再寒暑，百疠自辟易。 &emsp;&emsp;哀哉沮洳场，为我安乐国。岂有他缪巧，阴阳不能贼。顾此耿耿存，仰视浮云白。 &emsp;&emsp;悠悠我心悲，苍天曷有极。哲人日已远，典刑在夙昔。风檐展书读，古道照颜色。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前赤壁赋 –苏轼]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%89%8D%E8%B5%A4%E5%A3%81%E8%B5%8B-%E2%80%93%E8%8B%8F%E8%BD%BC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。 &emsp;&emsp;于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。 &emsp;&emsp;苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“月明星稀，乌鹊南飞，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” &emsp;&emsp;苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎!且夫天地之间，物各有主,苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” &emsp;&emsp;客喜而笑，洗盏更酌。肴核既尽，杯盘狼藉。相与枕藉乎舟中，不知东方之既白。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出师表 –诸葛亮]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%87%BA%E5%B8%88%E8%A1%A8-%E2%80%93%E8%AF%B8%E8%91%9B%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。 &emsp;&emsp;宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。 &emsp;&emsp;侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。 &emsp;&emsp;将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。 &emsp;&emsp;亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 &emsp;&emsp;臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。 &emsp;&emsp;先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。 &emsp;&emsp;愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。 &emsp;&emsp;今当远离，临表涕零，不知所言。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兰亭集序 –王羲之]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%85%B0%E4%BA%AD%E9%9B%86%E5%BA%8F-%E2%80%93%E7%8E%8B%E7%BE%B2%E4%B9%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;永和九年，岁在癸丑，暮春之初，会于会稽山阴之兰亭，修禊事也。群贤毕至，少长咸集。此地有崇山峻岭，茂林修竹，又有清流激湍，映带左右，引以为流觞曲水，列坐其次。虽无丝竹管弦之盛，一觞一咏，亦足以畅叙幽情。 &emsp;&emsp; 是日也，天朗气清，惠风和畅。仰观宇宙之大，俯察品类之盛，所以游目骋怀，足以极视听之娱，信可乐也。 &emsp;&emsp; 夫人之相与，俯仰一世。或取诸怀抱，悟言一室之内；或因寄所托，放浪形骸之外。虽趣舍万殊，静躁不同，当其欣于所遇，暂得于己，快然自足，不知老之将至；及其所之既倦，情随事迁，感慨系之矣。向之所欣，俯仰之间，已为陈迹，犹不能不以之兴怀，况修短随化，终期于尽！古人云：“死生亦大矣。”岂不痛哉！ &emsp;&emsp;每览昔人兴感之由，若合一契，未尝不临文嗟悼，不能喻之于怀。固知一死生为虚诞，齐彭殇为妄作。后之视今，亦犹今之视昔，悲夫！故列叙时人，录其所述，虽世殊事异，所以兴怀，其致一也。后之览者，亦将有感于斯文。]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱莲说 –周敦颐]]></title>
    <url>%2F2018%2F07%2F11%2F%E7%88%B1%E8%8E%B2%E8%AF%B4-%E2%80%93%E5%91%A8%E6%95%A6%E9%A2%90%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;水陆草木之花，可爱者甚蕃。晋陶渊明独爱菊。自李唐来，世人甚爱牡丹。予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清，亭亭净植，可远观而不可亵玩焉。 &emsp;&emsp;予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。噫！菊之爱，陶后鲜有闻。莲之爱，同予者何人？牡丹之爱，宜乎众矣！]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湖心亭看雪 –张岱]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%B9%96%E5%BF%83%E4%BA%AD%E7%9C%8B%E9%9B%AA-%E2%80%93%E5%BC%A0%E5%B2%B1%2F</url>
    <content type="text"><![CDATA[&emsp; &ensp; 崇祯五年十二月，余住西湖。大雪三日，湖中人鸟声俱绝。是日更定矣，余拏一小舟，拥毳衣炉火，独往湖心亭看雪。雾凇沆砀，天与云与山与水，上下一白。湖上影子，惟长堤一痕、湖心亭一点、与余舟一芥，舟中人两三粒而已。 &emsp; &ensp; 到亭上，有两人铺毡对坐，一童子烧酒炉正沸。见余，大喜曰：“湖中焉得更有此人！”拉余同饮。余强饮三大白而别。问其姓氏，是金陵人，客此。及下船，舟子喃喃曰：“莫说相公痴，更有痴似相公者！”]]></content>
      <categories>
        <category>古诗文</category>
      </categories>
      <tags>
        <tag>古诗文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孟婆汤]]></title>
    <url>%2F2018%2F07%2F11%2F%E5%AD%9F%E5%A9%86%E6%B1%A4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;母亲已有六十九个日夜不曾跟我讲一句话。 ​ 我还记得她从前抛下的荆棘一般的话语，“你记着，你是怎样对我的，总有一天我会以冷漠同样地还给你！”我也还记得小时候犯了错，在门缝后眼巴巴地望上她半天，她总会过来摸摸我的头，像揉一只毛绒小狗。 ​ “知道错了吗？” ​ 我温顺地点头。 ​ 她终究会原谅我，千千万万次。 ​ 寒风吹彻的日子，我只身一人回家，烧饭，浇花，洗衣服。然后坐上去往杭州的大巴。 ​ 这个城市的天空总是很奇怪，瓦蓝瓦蓝的时候不觉得舒畅，灰白灰白的时候也不觉得感伤，他总是高远而平静，如同活着跟没活似的生活。杭州的风背着一股湿气，像灌不完的孟婆汤。我的遗落的记忆，最终沉重地落在十月十一日的下午。 ​ “你们怎么来学校了？” ​ “知道你二模刚结束，带你出去放松心情呗。” ​ 签完请假单坐上车，车子驶出百米。驾驶座是阿姨塑料袋般窸窣颤抖的声音，“佳颖，我们去医院。”父亲坐在副驾驶座上，一言不发。潮湿，淹没了一切、一切声音。 我几乎是，一点认不出母亲来。她剃光了长发，脑袋浮肿得像个面团，手臂上是蛆虫似的伤口和紫黑紫黑的皮肤。只有那些错杂的管子和借助呼吸机剧烈起伏的胸口，让我确信，我的亲爱的母亲，她终究没有死亡。她原本是救不活了，她血管里汩汩流动的血液都几近流干了，她在短短三天之内动了三次大手术，她还在等我，可她终究没有睁开眼睛。 &emsp;&emsp;重症监护室里，我终究不敢号啕大哭。 ​ 这一次，母亲不会原谅我。 ​ 几天后母亲转院来杭州，我仍然被安置在那个空旷的小城里学习，过着平常得不能再平常的生活。我常常打开微信点开母亲的对话框，那里是母亲车祸前三小时发来的“鸡汤”，我甚至懒得把它读完。六十九天，我没舍得删，从“十年苦读竟成空心人”到“首要的是‘学会生活’”，一共一百八十个字，字字扎在我心里。 ​ 母亲醒了。是迷蒙的眼。 ​ 我在电话的这头泣不成声。父亲告诉我，她会像小孩子一样，她可能认不得我，她需要一件件事都从头学起。“你别担心，你认真学习就好了。” ​ “爸爸，我二模考了年级第五。妈妈她一直跟我说我有能力考前五的，这次我做到了。她还记得吗？” ​ 可是她永远都不知道了。 ​ 就算父亲问：“你是谁？”她也会答不上自己的名字，她只会胡言乱语，像一个走失在岁月里的孩子。 ​ 我以前总以为母亲功利愚昧世俗做作，我想要自由和梦想，我对她冷漠和苛刻。直到，真正失去的那天。我歇斯底里。 ​ 昨日的大巴在夜间抵达杭州，母亲啊，我没日没夜思念的母亲！ ​ 她的眼珠骨溜溜地转着，却不曾聚焦到我的脸上；她的头骨被剜去半块，模样有些狰狞；当我的手触及她的手，那里是母亲温热的血液，是我温故如新的回忆，是我忍住的干涸滚烫的泪水。 ​ 父亲在她耳边温柔地说：“认识吗？她是谁？” ​ 母亲骤然把她的温热的手缩回。 ​ 我的手，于她而言，太冰冷了。 ​ “是你女儿啊，不记得了？” ​ 她不记得了。 ​ “女儿来了不打声招呼？笑一下呀。” ​ 母亲忽然咧开嘴，露出两排整齐光洁的牙齿，像在等待一个牙医检查她的牙齿。 ​ 我把手捂热，再去牵她的手。我只是静默地望着她，用很深很深的目光凝视，我希望她会记起我。她转过头来，继而别过头去，她轻声说：“佳颖读书不认真。”那一瞬，我泪流满面。 ​ 寒风吹彻的日子，我只身一人前往赛场。人行道上，落叶和雨水打湿的地面紧紧抱在一起，它们太冷了。水啊，树啊，它们都很伤心的，它们忍得住就是了。 ​ 我忽然想起我的包里有一本《目送》，那是母亲读过的最后一本书，她的书签夹在第五十六页。我曾经嘲笑母亲看如此平淡琐碎、小家子气的书，但从母亲出事，直到现在，我已经将它翻了三遍，也许我的母亲会像龙应台的母亲一样，记不起重要的人和重要的事，但我仍然爱她。我有与你，永恒的记忆。 ​ 你会记得，有一个小姑娘，在你病床边，为你一遍又一遍地念你喜欢的书，就像你不曾记得的很久很久以前你教她一遍又一遍地认字一样。书的封面是你喜欢的藻绿色，是我们久久等待的春天。 ​ 妈妈，你还记得吗？ ​ 你是我的母亲，你叫陈学慧，你最爱的是绿萝和富贵竹。 ​ 我是你的女儿，我叫申屠佳颖，我最爱的，是你。]]></content>
      <categories>
        <category>文章佳句</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShadowsocksR一键安装脚本（转）]]></title>
    <url>%2F2018%2F07%2F11%2FShadowsocksR%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[本脚本适用环境：&emsp;&emsp;系统支持：CentOS，Debian，Ubuntu&emsp;&emsp;内存要求：≥128M&emsp;&emsp;日期：2017 年 07 月 27 日关于本脚本：&emsp;&emsp;一键安装 ShadowsocksR 服务端。&emsp;&emsp;请下载与之配套的客户端程序来连接。&emsp;&emsp;（以下客户端只有 Windows 客户端和 Python 版客户端可以使用 SSR 新特性，其他原版客户端只能以兼容的方式连接 SSR 服务器） 默认配置：&emsp;&emsp;服务器端口：自己设定（如不设定，默认为 8989）&emsp;&emsp;密码：自己设定（如不设定，默认为 teddysun.com）&emsp;&emsp;加密方式：自己设定（如不设定，默认为 aes-256-cfb）&emsp;&emsp;协议（Protocol）：自己设定（如不设定，默认为 origin）&emsp;&emsp;混淆（obfs）：自己设定（如不设定，默认为 plain） 客户端下载：&emsp;&emsp;Windows / OS X&emsp;&emsp;Linux&emsp;&emsp;Android / iOS&emsp;&emsp;OpenWRT 使用方法：&emsp;&emsp;使用root用户登录，运行以下命令： 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log &emsp;&emsp;安装完成后，脚本提示如下： 12345678910Congratulations, ShadowsocksR server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Protocol :your_protocolYour obfs :your_obfsYour Encryption Method:your_encryption_methodWelcome to visit:https://shadowsocks.be/9.htmlEnjoy it! 卸载方法：&emsp;&emsp;使用 root 用户登录，运行以下命令： 1./shadowsocksR.sh uninstall &emsp;&emsp;安装完成后即已后台启动 ShadowsocksR ，运行： 1/etc/init.d/shadowsocks status &emsp;&emsp;可以查看 ShadowsocksR 进程是否已经启动。&emsp;&emsp;本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。 使用命令：&emsp;&emsp;启动：/etc/init.d/shadowsocks start&emsp;&emsp;停止：/etc/init.d/shadowsocks stop&emsp;&emsp;重启：/etc/init.d/shadowsocks restart&emsp;&emsp;状态：/etc/init.d/shadowsocks status &emsp;&emsp;配置文件路径：/etc/shadowsocks.json&emsp;&emsp;日志文件路径：/var/log/shadowsocks.log&emsp;&emsp;代码安装目录：/usr/local/shadowsocks 多用户配置示例： 123456789101112131415161718192021&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;server_ipv6&quot;: &quot;[::]&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password1&quot;, &quot;8990&quot;:&quot;password2&quot;, &quot;8991&quot;:&quot;password3&quot;&#125;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;protocol&quot;: &quot;origin&quot;,&quot;protocol_param&quot;: &quot;&quot;,&quot;obfs&quot;: &quot;plain&quot;,&quot;obfs_param&quot;: &quot;&quot;,&quot;redirect&quot;: &quot;&quot;,&quot;dns_ipv6&quot;: false,&quot;fast_open&quot;: false,&quot;workers&quot;: 1&#125; &emsp;&emsp;如果你想修改配置文件，请参考：https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/Server-Setuphttps://github.com/shadowsocksr-backup/shadowsocks-rss/blob/master/ssr.mdhttps://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/config.json 更新日志：&emsp;&emsp;2017 年 07 月 27 日：&emsp;&emsp;&emsp;&emsp;1、新增：可选协议（protocol）auth_chain_b 。使用该协议需更新到最新版（4.7.0）ShadowsocksR 版客户端；&emsp;&emsp;&emsp;&emsp;2、修改：更新 ShadowsocksR 源码下载地址。 &emsp;&emsp;2017 年 07 月 22 日：&emsp;&emsp;&emsp;&emsp;1、新增：安装时可选 13 种加密方式的其中之一（none 是不加密）。如下所示： 1234567891011121314noneaes-256-cfbaes-192-cfbaes-128-cfbaes-256-cfb8aes-192-cfb8aes-128-cfb8aes-256-ctraes-192-ctraes-128-ctrchacha20-ietfchacha20rc4-md5rc4-md5-6 &emsp;&emsp;&emsp;&emsp;2、新增：安装时可选 7 种协议（protocol）的其中之一。如下所示： 12345678originverify_deflateauth_sha1_v4auth_sha1_v4_compatibleauth_aes128_md5auth_aes128_sha1auth_chain_aauth_chain_b &emsp;&emsp;&emsp;&emsp;3、新增：安装时可选 9 种混淆（obfs）的其中之一。如下所示： 123456789plainhttp_simplehttp_simple_compatiblehttp_posthttp_post_compatibletls1.2_ticket_authtls1.2_ticket_auth_compatibletls1.2_ticket_fastauthtls1.2_ticket_fastauth_compatible 2016 年 08 月 13 日：&emsp;&emsp;1、新增多用户配置示例。注意：如果你新增了端口，也要将该端口从防火墙（iptables 或 firewalld）中打开。 2016 年 05 月 12 日：&emsp;&emsp;1、新增在 CentOS 下的防火墙规则设置。 参考链接：https://github.com/shadowsocksr-backup/shadowsocksr]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于echo和重定向]]></title>
    <url>%2F2018%2F07%2F11%2F%E2%80%9D%E5%85%B3%E4%BA%8Eecho%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;众所周知，在Linux使用echo并配合命令重定向是实现向文件中写入信息的快捷方式；本文介绍如何将echo命令与sudo命令配合使用，实现向只有系统管理员才有权限操作的文件中写入信息（本文以普通用户身份为例）。 &emsp;&emsp;比如向普通文件test文件中写入信息，可以 1echo "The first message write" &gt; test &emsp;&emsp;或者追加写入 1echo "The second message" &gt;&gt; test &emsp;&emsp;下面，如果将test权限设置为只有root用户才有权进行写操作 12sudo chown root.root testsudo chmod 644 test &emsp;&emsp;我们使用sudo并配合echo命令再次向修改权限之后的test文件中写入信息： 1sudo echo "The third message write" &gt;&gt; test &emsp;&emsp;此时，会提示出错信息 1-bash: test: Permission denied &emsp;&emsp;bash拒绝这么做，原因是权限不够。这是因为重定向符号“&gt;”和”&gt;&gt;”也是bash命令。当我们使用sudo只是让echo命令具有了root权限，但并没有让”&gt;”和”&gt;&gt;”命令也酷游root权限，所以bash会认为这两个命令没有向test文件写入信息的权限。 &emsp;&emsp;为了解决这个问题，通常有两这方式。第一种是利用”sh -c”命令，它可以让bash将一个字符串作为完整的命令来执行，这样就可以将sudo的影响范围拓展到整条命令，具体方法如下： 1sudo sh -c 'echo "The fourth message write" &gt;&gt; test' &emsp;&emsp;另一种方法利用管道和tee命令，该命令可以从标准输入中读入信息并将其写入标准输出或文件中，具体用法如下： 1echo "The fifth message write" | sudo test -a test &emsp;&emsp;注意，tee命令的’-a’选项的作用等同于”&gt;&gt;”命令”&gt;&gt;”,如果去除该选项，那么tee命令的作用等同于”&gt;”命令。 &emsp;&emsp;本人最初是在linux上清理内存是遇到这个问题的，附上清理内存的命令 1sudo bash -c "echo 3 &gt; /proc/sys/vm/drop_caches" &emsp;&emsp;最后附上一个vim技巧，当你编辑一个read only文件时，可以在vim中使用如下命令保存对文件的更改： 1:w !sudo tee %]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
